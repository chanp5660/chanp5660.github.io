<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://chanp5660.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://chanp5660.github.io/" rel="alternate" type="text/html" hreflang="ko"/><updated>2024-12-20T06:06:33+00:00</updated><id>https://chanp5660.github.io/feed.xml</id><title type="html">ChanPark 박찬</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">옵시디언에서 일정 관리</title><link href="https://chanp5660.github.io/blog/2024/%EC%98%B5%EC%8B%9C%EB%94%94%EC%96%B8%EC%97%90%EC%84%9C-%EC%9D%BC%EC%A0%95-%EA%B4%80%EB%A6%AC/" rel="alternate" type="text/html" title="옵시디언에서 일정 관리"/><published>2024-12-19T00:00:00+00:00</published><updated>2024-12-19T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/%EC%98%B5%EC%8B%9C%EB%94%94%EC%96%B8%EC%97%90%EC%84%9C-%EC%9D%BC%EC%A0%95-%EA%B4%80%EB%A6%AC</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/%EC%98%B5%EC%8B%9C%EB%94%94%EC%96%B8%EC%97%90%EC%84%9C-%EC%9D%BC%EC%A0%95-%EA%B4%80%EB%A6%AC/"><![CDATA[<p>연결 문서</p> <h1 id="옵시디언에서-일정-관리">옵시디언에서 일정 관리</h1> <p>이 문서에서는 Obsidian을 활용한 일정 관리 방법을 단계별로 정리합니다. 주로 다음과 같은 플러그인을 사용할 예정입니다.</p> <ul> <li><strong>Periodic Notes</strong>: 날짜별 노트를 자동 생성해 일정 및 할 일을 기록</li> <li><strong>Tasks</strong>: 할 일(Task)을 만들고 날짜, 기한, 완료 여부 등을 쉽게 관리</li> <li><strong>Task List Kanban</strong>: Task들을 칸반 형태로 시각화하여 전체 일정 파악을 용이하게 함</li> </ul> <p>아래에서는 각 단계를 세부적으로 설명하고 예시를 들어 다른 사람도 쉽게 따라 할 수 있도록 합니다.</p> <h2 id="1-periodic-notes로-일일-노트-생성하기">1. Periodic Notes로 일일 노트 생성하기</h2> <h3 id="주요-기능">주요 기능</h3> <ul> <li><strong>일간 노트(Daily Note)</strong>, 주간 노트(Weekly Note), 월간 노트(Monthly Note) 등 특정 기간을 기준으로 한 노트를 자동으로 생성</li> <li>날짜 기반의 파일명 및 템플릿을 통한 일정 관리 자동화</li> </ul> <h3 id="설정-방법">설정 방법</h3> <ol> <li><strong>플러그인 설치</strong>:<br/> Obsidian 설정(Preferences) &gt; Community plugins &gt; Browse 에서 <code class="language-plaintext highlighter-rouge">Periodic Notes</code> 검색 후 설치 및 활성화</li> <li><strong>기본 설정</strong>:<br/> Periodic Notes 설정 메뉴에서 일일 노트(Daily), 주간 노트(Weekly), 월간 노트(Monthly) 등을 설정할 수 있습니다. <ul> <li>예: Daily Notes 폴더를 <code class="language-plaintext highlighter-rouge">Daily</code>로 지정, 파일명 패턴을 <code class="language-plaintext highlighter-rouge">YYYY-MM-DD</code> 형식으로 설정</li> <li>기본 템플릿을 지정해두면 매일 동일한 서식을 가진 노트가 자동으로 생성됩니다.</li> </ul> </li> </ol> <h3 id="예시">예시</h3> <p>매일 아침 Obsidian을 열어 <code class="language-plaintext highlighter-rouge">Command Palette(Ctrl/Cmd + P)</code>에서 <code class="language-plaintext highlighter-rouge">Open today's daily note</code> 명령을 실행하면 <code class="language-plaintext highlighter-rouge">2024-12-19.md</code> 형태의 일일 노트가 자동 생성되고, 미리 지정한 템플릿에 따라 다음과 같은 내용이 시작 부분에 나타납니다.</p> <div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># 2024-12-19 (일일 노트)</span>

<span class="gu">## 오늘의 목표</span>
<span class="p">-</span> [ ] 주요 프로젝트 X 마감 준비
<span class="p">-</span> [ ] 회의 준비

<span class="gu">## 주요 일정</span>
<span class="p">-</span> 오전 10시: 팀 미팅 (Zoom)
<span class="p">-</span> 오후 3시: 클라이언트 전화 미팅

<span class="gu">## 할 일(Task) 목록</span>
</code></pre></div></div> <p>이렇게 매일 새로운 노트를 생성해, 그날 할 일과 목표를 기록해 나갈 수 있습니다.</p> <h2 id="2-tasks-플러그인을-이용한-일정-및-할-일-관리">2. Tasks 플러그인을 이용한 일정 및 할 일 관리</h2> <h3 id="주요-기능-1">주요 기능</h3> <ul> <li>Obsidian 메모 내에 <code class="language-plaintext highlighter-rouge">- [ ]</code> 형태로 적힌 할 일을 중앙 관리</li> <li>마감일(due date), 시작일(start date), 반복 여부, 우선순위 등을 태그처럼 지정 가능</li> <li>필터링 및 정렬 기능으로 다양한 뷰를 제공</li> </ul> <h3 id="설정-방법-1">설정 방법</h3> <ol> <li> <p><strong>플러그인 설치</strong>:<br/> Obsidian 설정 &gt; Community plugins &gt; Browse 에서 <code class="language-plaintext highlighter-rouge">Tasks</code> 검색 후 설치 및 활성화</p> </li> <li> <p><strong>할 일 작성</strong>:<br/> 할 일은 다음 형식으로 노트 어디서든 작성할 수 있습니다.</p> <div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p"> -</span> [ ] 할 일 내용
</code></pre></div> </div> <p>이 때 Tasks 플러그인이 인식하는 날짜나 메타데이터를 추가하고 싶다면 다음과 같이 작성합니다.</p> <div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p"> -</span> [ ] 보고서 초안 작성하기  
   📅 due: 2024-12-20  
   🛫 start: 2024-12-18  
   # 중요 (태그 활용)
</code></pre></div> </div> </li> <li> <p><strong>Tasks Query 사용</strong>:<br/> 특정 노트에 쿼리를 작성해 프로젝트별, 날짜별, 태그별 할 일을 필터링할 수 있습니다.</p> <div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">```</span><span class="nl">tasks
</span><span class="sb"> not done
 due before 2024-12-21
 sort by due
</span></code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 위 쿼리는 아직 완료하지 않은(nod done) 할 일 중 마감일(due)이 2024-12-21 이전인 것을 찾아 마감일 순서로 정렬합니다.
</code></pre></div> </div> </li> </ol> <h3 id="예시-1">예시</h3> <p><code class="language-plaintext highlighter-rouge">Daily/2024-12-19.md</code> 노트에 다음과 같이 Tasks를 작성했다고 가정해 봅시다.</p> <div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># 2024-12-19 (일일 노트)</span>

<span class="gu">## 오늘 할 일</span>
<span class="p">-</span> [ ] 팀 회의록 작성하기  
  📅 due: 2024-12-19  
  🛫 start: 2024-12-19  
  # 회의록
<span class="p">
-</span> [ ] 광고 캠페인 초안 작성  
  📅 due: 2024-12-20  
  # 마케팅
</code></pre></div></div> <p>이제 <code class="language-plaintext highlighter-rouge">마케팅.md</code>라는 노트에 다음과 같이 쿼리를 넣어 <code class="language-plaintext highlighter-rouge">#마케팅</code> 태그가 붙은 할 일을 한눈에 확인할 수 있습니다.</p> <div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># 마케팅 관련 업무</span>

<span class="p">```</span><span class="nl">tasks
</span><span class="sb">tag includes #마케팅
not done
sort by due
</span></code></pre></div></div> <p>이렇게 하면 마케팅 태그가 붙은 모든 노트 내의 할 일을 모아서 보여줍니다.</p> <h2 id="3-task-list-kanban으로-시각화하기">3. Task List Kanban으로 시각화하기</h2> <h3 id="주요-기능-2">주요 기능</h3> <ul> <li>Task 목록을 칸반보드 형태로 시각화</li> <li>할 일을 카드 형태로 끌어다니며 진행상태(Board column)를 변경</li> <li>단순 체크박스가 아닌, 상태 변경 및 진행 과정 확인이 용이</li> </ul> <h3 id="설정-방법-2">설정 방법</h3> <ol> <li><strong>플러그인 설치</strong>:<br/> <code class="language-plaintext highlighter-rouge">Task List Kanban</code> 플러그인을 Community plugins에서 검색 후 설치 및 활성화합니다.</li> <li><strong>새 칸반보드 생성</strong>:<br/> Command Palette에서 <code class="language-plaintext highlighter-rouge">Create new Task List Kanban</code>를 실행하거나, 빈 노트에 칸반용 Markdown 템플릿을 직접 작성할 수 있습니다.</li> </ol> <h3 id="예시-2">예시</h3> <p><code class="language-plaintext highlighter-rouge">project-kanban.md</code>라는 노트를 생성하고 다음과 같이 칸반 템플릿을 작성합니다.</p> <div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">kanban-plugin</span><span class="pi">:</span> <span class="s">basic</span>
<span class="nn">---</span>

<span class="gh"># 프로젝트 진행 현황</span>

<span class="gu">## 할 일 (To Do)</span>
<span class="p">-</span> [ ] 보고서 초안 작성하기  
  📅 due: 2024-12-20
<span class="p">-</span> [ ] 광고 캠페인 초안 작성  
  📅 due: 2024-12-20  
  #마케팅

<span class="gu">## 진행 중 (In Progress)</span>
<span class="p">-</span> [ ] 팀 회의록 정리하기  
  📅 due: 2024-12-19

<span class="gu">## 완료 (Done)</span>
</code></pre></div></div> <p>이제 이 노트를 Kanban View로 전환하면, 할 일을 drag &amp; drop 으로 “할 일(To Do)” → “진행 중(In Progress)” → “완료(Done)” 순으로 옮길 수 있습니다. Tasks 플러그인으로 관리되는 할 일이므로, 이 칸반에서도 체크박스를 통해 완료 상태를 변경할 수 있고, due date나 태그가 인식되어 전체적인 일정과 할 일을 한눈에 파악할 수 있게 됩니다.</p> <h2 id="활용-시나리오-요약">활용 시나리오 요약</h2> <ol> <li> <p><strong>매일 아침 Periodic Notes로 당일 노트 생성</strong>:<br/> 매일 새로운 일일 노트를 열어 그날 할 일과 목표를 기록합니다.</p> </li> <li> <p><strong>Tasks 플러그인으로 중앙 관리</strong>:<br/> 일일 노트나 특정 프로젝트 노트 등 어디서든 할 일을 적으면, Tasks 쿼리를 통해 프로젝트별/태그별/기한별로 할 일을 손쉽게 추출할 수 있습니다.</p> </li> <li> <p><strong>Task List Kanban으로 시각화</strong>:<br/> 여러 Tasks를 하나의 Kanban 보드에 모아 전체 프로젝트 현황을 한눈에 파악하고, 단계별(Column)로 업무를 전환하며 진행 과정을 직관적으로 관리할 수 있습니다.</p> </li> </ol> <h2 id="마무리">마무리</h2> <p>이 가이드는 Obsidian에서 Periodic Notes, Tasks, Task List Kanban 플러그인을 통해 일정 관리 시스템을 구축하는 방법을 예시와 함께 소개했습니다. 이 접근 방식을 통해 다음을 기대할 수 있습니다.</p> <ul> <li>날짜 기반으로 할 일을 기록하고, 마감일을 손쉽게 관리</li> <li>태그 및 쿼리를 통한 다차원적 할 일 관리</li> <li>시각적 칸반 뷰를 통한 프로젝트 진행 상황 한눈에 파악</li> </ul> <p>해당 방법을 참고하여 자신만의 생산성 워크플로우를 만들어 보세요.</p>]]></content><author><name></name></author><category term="옵시디언/일정관리"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">LangChain Expression Language(LCEL)</title><link href="https://chanp5660.github.io/blog/2024/LangChain-Expression-Language(LCEL)/" rel="alternate" type="text/html" title="LangChain Expression Language(LCEL)"/><published>2024-12-10T00:00:00+00:00</published><updated>2024-12-10T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/LangChain-Expression-Language(LCEL)</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/LangChain-Expression-Language(LCEL)/"><![CDATA[<p>연결 문서</p> <p><a href="https://wikidocs.net/233344">랭체인노트 - # 05. LangChain Expression Language(LCEL)</a></p> <h1 id="langchain-expression-languagelcel">LangChain Expression Language(LCEL)</h1> <p>AI 워크플로우를 효율적으로 구성하기 위해서는 데이터 흐름, 모델 호출, 그리고 결과 처리 단계를 체계적으로 관리할 수 있는 프레임워크가 필요합니다. <strong>LangChain</strong>은 이러한 요구를 충족시키는 강력한 솔루션이며, 그중 <strong>LangChain Expression Language(LCEL)</strong> 는 LangChain의 다양한 구성 요소(프롬프트 템플릿, 모델, 출력 파서)를 언어적 표현으로 연결해, 한층 더 직관적이고 유연한 방식으로 AI 작업을 오케스트레이션할 수 있게 해줍니다.</p> <p>이번 글에서는 LCEL의 개념과 역할, <code class="language-plaintext highlighter-rouge">invoke</code> 메서드의 설계 철학, <code class="language-plaintext highlighter-rouge">input</code> 데이터 구조의 이유, 그리고 <strong>출력 파서(Output Parser)</strong> 의 필요성과 활용 방안을 다룹니다. 또한 간단한 예제를 넘어 다단계 체인과 다양한 파서 적용 사례까지 살펴보며 LCEL을 통한 실무적 활용 방안을 제시합니다.</p> <hr/> <h2 id="lcel이란-무엇인가">LCEL이란 무엇인가?</h2> <p>LCEL은 LangChain이 제공하는 추상화 레벨 중 하나로, 사용자에게 <strong>프롬프트 템플릿</strong>, <strong>모델</strong>, <strong>출력 파서</strong> 등을 언어적 표현으로 연결하는 파이프(<code class="language-plaintext highlighter-rouge">|</code>) 기반 문법을 제공합니다. 이를 통해 기존에 코드 상에서 명시적으로 데이터 흐름을 제어하던 작업을 보다 직관적이고 선언적인 방식으로 표현할 수 있습니다.</p> <ul> <li><strong>기존 LangChain 체인 구성</strong>: 함수나 메서드 호출로 체인을 구성.</li> <li><strong>LCEL을 활용한 구성</strong>: 파이프(<code class="language-plaintext highlighter-rouge">|</code>) 연산자를 사용한 언어적 표현으로 체인의 로직을 단순화하고, 읽기 좋은 “데이터 흐름 그래프”를 쉽게 구현.</li> </ul> <p>LCEL은 이처럼 <strong>프롬프트 → 모델 호출 → 출력 파서</strong>의 일련의 과정을 유연하고 명확하게 연결함으로써 복잡한 AI 워크플로우를 효율적으로 관리하는 데 기여합니다.</p> <hr/> <h2 id="프롬프트-템플릿prompt-template">프롬프트 템플릿(Prompt Template)</h2> <p>프롬프트 템플릿은 사용자가 제공하는 변수를 바탕으로 모델이 이해하기 쉬운 문자열(프롬프트)을 동적으로 생성합니다. 이를 통해 단순히 하나의 질문을 던지는 것이 아니라, 상황에 따라 다양한 변수를 삽입한 맞춤형 질의를 모델에게 전달할 수 있습니다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">langchain_core.prompts</span> <span class="kn">import</span> <span class="n">PromptTemplate</span>

<span class="n">template</span> <span class="o">=</span> <span class="sh">"</span><span class="s">{country}의 수도는 어디인가요?</span><span class="sh">"</span>
<span class="n">prompt_template</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">.</span><span class="nf">from_template</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

<span class="n">prompt</span> <span class="o">=</span> <span class="n">prompt_template</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">country</span><span class="o">=</span><span class="sh">"</span><span class="s">대한민국</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">prompt</span><span class="p">)</span>  <span class="c1"># 출력: 대한민국의 수도는 어디인가요?
</span></code></pre></div></div> <hr/> <h2 id="모델-호출과-invoke-메서드">모델 호출과 <code class="language-plaintext highlighter-rouge">invoke</code> 메서드</h2> <p>LCEL의 체인 상에서 입력값을 전달하고 모델을 호출할 때는 <code class="language-plaintext highlighter-rouge">invoke</code> 메서드를 사용합니다. <code class="language-plaintext highlighter-rouge">invoke</code>는 <strong>입력을 주고, 처리 과정을 시작한다</strong>는 의미를 잘 함축하고 있으며, AWS Lambda나 Java Reflection 등 다양한 시스템에서 함수 호출의 의미로 널리 활용되는 표현입니다.</p> <ul> <li><code class="language-plaintext highlighter-rouge">invoke</code>를 선택한 이유: <ul> <li><strong>직관성</strong>: “호출하다”, “시작하다”라는 의미로 프로세스 실행 의도를 명확히 표현.</li> <li><strong>관용적 사용</strong>: 다양한 기술 스택에서 이미 유사한 의미로 사용, 친숙함 제공.</li> <li><strong>대안 단어 비교</strong>: <code class="language-plaintext highlighter-rouge">call</code>이나 <code class="language-plaintext highlighter-rouge">run</code>은 지나치게 일반적이거나 의도가 애매할 수 있으나 <code class="language-plaintext highlighter-rouge">invoke</code>는 입력 전달 및 실행 개시를 더 명확히 드러냄.</li> </ul> </li> </ul> <p>아래 예제에서는 이미 만든 프롬프트를 모델에 직접 전달합니다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">langchain_openai</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>

<span class="n">model</span> <span class="o">=</span> <span class="nc">ChatOpenAI</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="sh">"</span><span class="s">gpt-3.5-turbo</span><span class="sh">"</span><span class="p">,</span> <span class="n">max_tokens</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="sh">"</span><span class="s">대한민국의 수도는 어디인가요?</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>  <span class="c1"># 출력: "대한민국의 수도는 서울입니다."
</span></code></pre></div></div> <hr/> <h2 id="체인-생성과-파이프-연산자">체인 생성과 파이프 연산자(<code class="language-plaintext highlighter-rouge">|</code>)</h2> <p>LCEL에서는 프롬프트 템플릿, 모델, 출력 파서 등을 파이프(<code class="language-plaintext highlighter-rouge">|</code>) 연산자로 연결할 수 있습니다. 이는 마치 Unix 파이프와 유사하게 <strong>데이터 흐름을 직관적으로 표현</strong>하여, 각 단계의 역할을 명확히 볼 수 있도록 합니다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prompt</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">.</span><span class="nf">from_template</span><span class="p">(</span><span class="sh">"</span><span class="s">{topic}에 대해 설명해주세요.</span><span class="sh">"</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="nc">ChatOpenAI</span><span class="p">()</span>

<span class="n">chain</span> <span class="o">=</span> <span class="n">prompt</span> <span class="o">|</span> <span class="n">model</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">chain</span><span class="p">.</span><span class="nf">invoke</span><span class="p">({</span><span class="sh">"</span><span class="s">topic</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">인공지능 모델의 학습 원리</span><span class="sh">"</span><span class="p">})</span>
<span class="nf">print</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</code></pre></div></div> <p>위 예제에서는 <code class="language-plaintext highlighter-rouge">{topic}</code>에 “인공지능 모델의 학습 원리”라는 입력이 전달되고, 해당 프롬프트가 모델로 흐른 뒤 결과가 반환됩니다.</p> <hr/> <h2 id="input-왜-dict-형태인가"><code class="language-plaintext highlighter-rouge">input</code>: 왜 <code class="language-plaintext highlighter-rouge">dict</code> 형태인가?</h2> <p>LangChain은 입력을 딕셔너리(<code class="language-plaintext highlighter-rouge">dict</code>) 형태로 받습니다. 이는 다음과 같은 장점을 제공합니다.</p> <ol> <li> <p><strong>다중 변수 지원</strong>: 여러 변수를 명확히 관리할 수 있습니다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">input</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">홍길동</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">topic</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">파이썬</span><span class="sh">"</span><span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>가독성과 명확성</strong>: 키-값 쌍으로 의미를 명확히 전달할 수 있습니다.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># 명확하지 않은 리스트
</span> <span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">홍길동</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">파이썬</span><span class="sh">"</span><span class="p">]</span>
    
 <span class="c1"># 명확한 딕셔너리
</span> <span class="nb">input</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">홍길동</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">topic</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">파이썬</span><span class="sh">"</span><span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>확장성</strong>: 필요 시 쉽게 변수 추가 가능.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">input</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">홍길동</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">topic</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">파이썬</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">urgency</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">높음</span><span class="sh">"</span><span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>프롬프트 템플릿 연동</strong>: <code class="language-plaintext highlighter-rouge">"{key}"</code> 형태로 템플릿에 매핑 가능.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">prompt</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">.</span><span class="nf">from_template</span><span class="p">(</span><span class="sh">"</span><span class="s">{name}님, {topic}에 대해 설명해주세요.</span><span class="sh">"</span><span class="p">)</span>
 <span class="n">formatted_prompt</span> <span class="o">=</span> <span class="n">prompt</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="o">**</span><span class="nb">input</span><span class="p">)</span>
</code></pre></div> </div> </li> </ol> <hr/> <h2 id="출력-파서output-parser-필요성과-활용">출력 파서(Output Parser): 필요성과 활용</h2> <p><strong>출력 파서(Output Parser)</strong> 는 모델의 응답을 특정 형식으로 변환하거나 구조화하는 역할을 합니다. 단순한 문자열 출력 이외에도 JSON, 딕셔너리, 리스트, CSV 등 다양한 형태로 가공할 수 있어, 후속 체인 처리나 다른 시스템과의 연동을 용이하게 합니다.</p> <h3 id="출력-파서의-역할">출력 파서의 역할</h3> <ol> <li><strong>출력 정리</strong>: 모델 응답을 단순한 문자열 대신 정돈된 형태로 변환.</li> <li><strong>구조화된 데이터 생성</strong>: JSON, 딕셔너리 등 원하는 데이터 구조로 가공.</li> <li><strong>후속 처리 준비</strong>: 체인의 다음 단계에서 쉽게 활용할 수 있도록 출력 형식을 표준화.</li> <li><strong>필수 사항은 아님</strong>: 단순 텍스트 응답만 필요하다면 생략 가능. 하지만 복잡한 응답 처리가 필요한 경우 필수적.</li> </ol> <h3 id="다양한-출력-파서-예시">다양한 출력 파서 예시</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">langchain_core.output_parsers</span> <span class="kn">import</span> <span class="n">StrOutputParser</span><span class="p">,</span> <span class="n">JSONOutputParser</span>

<span class="c1"># 단순 문자열 파서
</span><span class="n">str_parser</span> <span class="o">=</span> <span class="nc">StrOutputParser</span><span class="p">()</span>
<span class="n">parsed_str</span> <span class="o">=</span> <span class="n">str_parser</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="sh">"</span><span class="s">이것은 AI 응답입니다.</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">parsed_str</span><span class="p">)</span>  <span class="c1"># "이것은 AI 응답입니다."
</span>
<span class="c1"># JSON 파서
</span><span class="n">json_parser</span> <span class="o">=</span> <span class="nc">JSONOutputParser</span><span class="p">()</span>
<span class="n">parsed_json</span> <span class="o">=</span> <span class="n">json_parser</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="sh">'</span><span class="s">{</span><span class="sh">"</span><span class="s">key</span><span class="sh">"</span><span class="s">: </span><span class="sh">"</span><span class="s">value</span><span class="sh">"</span><span class="s">}</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">parsed_json</span><span class="p">)</span>  <span class="c1"># {'key': 'value'}
</span></code></pre></div></div> <h3 id="상황별-출력-파서-선택-가이드">상황별 출력 파서 선택 가이드</h3> <ul> <li><strong>단순 텍스트 활용</strong>: <code class="language-plaintext highlighter-rouge">StrOutputParser</code> 사용.</li> <li><strong>정형 데이터 필요(후속 연산 필요)</strong>: <code class="language-plaintext highlighter-rouge">JSONOutputParser</code> 또는 맞춤형 파서 활용.</li> <li><strong>커스텀 포맷 요구</strong>: CSV나 특정 텍스트 포맷을 원하는 경우 커스텀 파서 구현 가능.</li> </ul> <hr/> <h2 id="심화-예제-다단계-체인과-다양한-파서-적용">심화 예제: 다단계 체인과 다양한 파서 적용</h2> <p>다음 예제는 하나의 프롬프트로부터 시작하여, <strong>여러 단계를 거치는 체인</strong>을 보여줍니다.</p> <ol> <li>첫 번째 모델에서 사용자의 요청을 분석하고, <strong>JSON 형식</strong>으로 결과를 반환.</li> <li>두 번째 단계에서 JSON 응답을 파싱하고, 해당 데이터에 기반한 추가 프롬프트를 생성.</li> <li>최종적으로 다른 모델을 사용해 결과를 정리하고 문자열로 반환.</li> </ol> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">langchain_core.prompts</span> <span class="kn">import</span> <span class="n">PromptTemplate</span>
<span class="kn">from</span> <span class="n">langchain_core.output_parsers</span> <span class="kn">import</span> <span class="n">JSONOutputParser</span><span class="p">,</span> <span class="n">StrOutputParser</span>
<span class="kn">from</span> <span class="n">langchain_openai</span> <span class="kn">import</span> <span class="n">ChatOpenAI</span>

<span class="c1"># 1단계: 사용자 요청 분석 및 JSON 응답
</span><span class="n">analysis_prompt</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">.</span><span class="nf">from_template</span><span class="p">(</span><span class="sh">"</span><span class="s">사용자의 요청: {request}</span><span class="se">\n</span><span class="s">이 요청을 </span><span class="sh">'</span><span class="s">action</span><span class="sh">'</span><span class="s">과 </span><span class="sh">'</span><span class="s">object</span><span class="sh">'</span><span class="s"> 필드를 가진 JSON으로 분석하세요.</span><span class="sh">"</span><span class="p">)</span>
<span class="n">analysis_model</span> <span class="o">=</span> <span class="nc">ChatOpenAI</span><span class="p">()</span>

<span class="c1"># JSON으로 파싱하기 위한 파서
</span><span class="n">json_parser</span> <span class="o">=</span> <span class="nc">JSONOutputParser</span><span class="p">()</span>

<span class="n">analysis_chain</span> <span class="o">=</span> <span class="n">analysis_prompt</span> <span class="o">|</span> <span class="n">analysis_model</span> <span class="o">|</span> <span class="n">json_parser</span>

<span class="n">analysis_result</span> <span class="o">=</span> <span class="n">analysis_chain</span><span class="p">.</span><span class="nf">invoke</span><span class="p">({</span><span class="sh">"</span><span class="s">request</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">한국의 수도를 영어로 알려줘</span><span class="sh">"</span><span class="p">})</span>
<span class="c1"># 예: {"action": "translate", "object": "서울"}
</span>
<span class="c1"># 2단계: JSON 응답 기반 추가 질의
</span><span class="n">followup_prompt</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">.</span><span class="nf">from_template</span><span class="p">(</span><span class="sh">"</span><span class="s">action이 </span><span class="sh">'</span><span class="s">{action}</span><span class="sh">'</span><span class="s">이고 object가 </span><span class="sh">'</span><span class="s">{object}</span><span class="sh">'</span><span class="s">일 때, 결과를 한 문장으로 요약해주세요.</span><span class="sh">"</span><span class="p">)</span>
<span class="n">followup_model</span> <span class="o">=</span> <span class="nc">ChatOpenAI</span><span class="p">()</span>

<span class="c1"># JSON 출력에서 action, object를 추출하여 followup_prompt에 전달
</span><span class="n">followup_chain</span> <span class="o">=</span> <span class="n">followup_prompt</span> <span class="o">|</span> <span class="n">followup_model</span> <span class="o">|</span> <span class="nc">StrOutputParser</span><span class="p">()</span>

<span class="n">followup_response</span> <span class="o">=</span> <span class="n">followup_chain</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">analysis_result</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">followup_response</span><span class="p">)</span>
<span class="c1"># 예: "서울은 영어로 Seoul이라고 합니다."
</span></code></pre></div></div> <p>이 예제에서:</p> <ul> <li>첫 번째 체인: 사용자의 요청을 분석한 뒤 JSON 형태로 결과를 반환하도록 구성.</li> <li>두 번째 체인: JSON 파싱 결과(<code class="language-plaintext highlighter-rouge">analysis_result</code>)를 follow-up 프롬프트로 전달하고, 최종적으로 문자열로 응답.</li> </ul> <p>이런 다단계 구성은 LCEL이 제공하는 문법(파이프 <code class="language-plaintext highlighter-rouge">|</code>)과 출력 파서를 활용해 복잡한 로직을 단순화하고, 각 단계를 재사용 가능하게 만드는 한 예시입니다.</p> <hr/> <h2 id="결론">결론</h2> <p>LangChain은 LCEL을 통해 프롬프트 템플릿, 모델, 출력 파서와 같은 구성 요소를 직관적으로 연결하고, 복잡한 AI 워크플로우를 효율적으로 관리할 수 있습니다.</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">invoke</code> 메서드</strong>: 입력 데이터 전달 및 프로세스 시작을 직관적으로 표현.</li> <li><strong>입력 형식(<code class="language-plaintext highlighter-rouge">dict</code>)</strong>: 다중 변수 관리와 확장에 유리.</li> <li><strong>출력 파서</strong>: 모델 응답을 구조화하고, 후속 작업에 적합한 형식으로 변환하는 핵심 도구.</li> </ul> <p>LCEL은 이러한 장점을 통해, 코드의 가독성과 재사용성을 높이고 AI 파이프라인 구축을 손쉽게 해줍니다. 여러분의 프로젝트에 LCEL을 도입하여 더욱 강력하고 유연한 AI 워크플로우를 경험해보세요!</p>]]></content><author><name></name></author><category term="LLM"/><category term="LLM/Langchain"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">우도(likelihood)</title><link href="https://chanp5660.github.io/blog/2024/%EC%9A%B0%EB%8F%84(likelihood)/" rel="alternate" type="text/html" title="우도(likelihood)"/><published>2024-10-22T00:00:00+00:00</published><updated>2024-10-22T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/%EC%9A%B0%EB%8F%84(likelihood)</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/%EC%9A%B0%EB%8F%84(likelihood)/"><![CDATA[<p>연결 문서</p> <h1 id="우도likelihood">우도(likelihood)</h1> <p>통계학을 공부하다 보면 <strong>우도(Likelihood)</strong> 라는 용어를 자주 접하게 됩니다. 하지만 처음 접하는 분들에게는 다소 생소할 수 있는데요. 이 글에서는 우도가 무엇인지, 그리고 일상적인 예시를 통해 쉽게 이해해 보겠습니다.</p> <h2 id="우도란-무엇인가">우도란 무엇인가?</h2> <p><strong>우도</strong>는 관찰된 데이터가 특정한 조건이나 모수(parameter) 아래에서 나왔을 가능성을 나타내는 척도입니다. 쉽게 말해, <strong>“현재의 데이터가 주어졌을 때, 이 데이터를 만들어낸 원인이 무엇일까?”</strong> 를 고민하는 것입니다.</p> <h3 id="우도와-확률의-차이점">우도와 확률의 차이점</h3> <p>많은 분들이 우도와 확률을 혼동하곤 합니다. 하지만 두 개념은 방향성이 반대입니다.</p> <ul> <li><strong>확률(Probability)</strong>: 어떤 원인이 주어졌을 때, 그 결과가 나올 가능성입니다. <ul> <li>예: “공평한 주사위를 던졌을 때 6이 나올 확률은 얼마일까?”</li> </ul> </li> <li><strong>우도(Likelihood)</strong>: 어떤 결과가 주어졌을 때, 그 결과를 만들어낸 원인이 무엇일 가능성이 높을까를 평가합니다. <ul> <li>예: “주사위를 여러 번 던졌더니 6이 많이 나왔다. 이 주사위가 공평할 가능성은 얼마나 될까?”</li> </ul> </li> </ul> <h3 id="일반적인-예시-동전-던지기">일반적인 예시: 동전 던지기</h3> <p>동전 던지기는 통계학에서 자주 사용되는 예시입니다.</p> <p><strong>상황</strong>:</p> <ul> <li>동전을 10번 던졌는데, 8번이 앞면이 나왔습니다.</li> </ul> <p><strong>질문</strong>:</p> <ul> <li>이 동전은 공평한 동전일까요?</li> </ul> <p><strong>분석</strong>:</p> <ul> <li><strong>확률적 관점</strong>: 공평한 동전이라면 앞면이 나올 확률은 0.5입니다. 따라서 10번 중 8번 앞면이 나올 확률은 매우 낮습니다.</li> <li><strong>우도적 관점</strong>: 관찰된 결과(8번의 앞면)를 가장 잘 설명하는 동전의 특성(앞면이 나올 확률)은 무엇일까요? 이 경우, 앞면이 나올 확률이 0.8인 동전일 가능성이 높습니다.</li> </ul> <h3 id="일상생활-예시-미스터리-케이크">일상생활 예시: 미스터리 케이크</h3> <p><strong>상황</strong>:</p> <ul> <li>친구가 만든 케이크를 먹었는데, 너무 짭니다.</li> </ul> <p><strong>질문</strong>:</p> <ul> <li>왜 케이크가 이렇게 짤까요?</li> </ul> <p><strong>가능한 원인</strong>:</p> <ol> <li><strong>설탕 대신 소금을 넣었다.</strong></li> <li><strong>레시피보다 소금을 많이 넣었다.</strong></li> <li><strong>짠 재료(예: 치즈)를 추가했다.</strong></li> </ol> <p><strong>우도 평가</strong>:</p> <ul> <li>관찰된 결과는 “케이크가 짜다”입니다.</li> <li>각 원인이 이 결과를 얼마나 잘 설명하는지 평가합니다. <ul> <li><strong>설탕 대신 소금을 넣었다</strong>: 케이크가 매우 짤 가능성이 높습니다.</li> <li><strong>소금을 많이 넣었다</strong>: 짤 수 있지만, 설탕 대신 소금을 넣은 것보다는 덜 짤 수 있습니다.</li> <li><strong>짠 재료를 추가했다</strong>: 짤 수 있지만, 어느 정도인지에 따라 다릅니다.</li> </ul> </li> </ul> <p><strong>결론</strong>:</p> <ul> <li>케이크의 짠 정도를 고려했을 때, <strong>“설탕 대신 소금을 넣었다”</strong> 는 가설의 우도가 가장 높습니다.</li> </ul> <h3 id="우도의-중요성">우도의 중요성</h3> <p>우도는 통계 추론에서 매우 중요한 역할을 합니다.</p> <ul> <li><strong>최대우도추정법(MLE)</strong>: 관찰된 데이터를 가장 잘 설명하는 모수(parameter)를 찾는 방법입니다.</li> <li>데이터 분석, 기계 학습 등에서 모델을 최적화하는 데 사용됩니다.</li> </ul> <h3 id="결론">결론</h3> <p>우도는 <strong>“주어진 결과를 가장 잘 설명하는 원인은 무엇인가?”</strong> 를 고민하는 개념입니다. 일상생활에서도 자연스럽게 사용하고 있으며, 통계학의 핵심적인 부분입니다. 처음에는 조금 어렵게 느껴질 수 있지만, 주변의 예시를 통해 생각해 보면 이해하기 쉬워집니다.</p> <h2 id="응용">응용</h2> <h3 id="좀-더-어려운-예시-정규분포와-최대우도추정법mle">좀 더 어려운 예시: 정규분포와 최대우도추정법(MLE)</h3> <p><strong>상황</strong>:</p> <ul> <li>어떤 공장에서 생산되는 부품의 길이는 정규분포를 따른다고 알려져 있습니다.</li> <li>하지만 정확한 평균(μ)과 표준편차(σ)는 알 수 없습니다.</li> <li> <p>랜덤하게 선택한 10개의 부품의 길이를 측정했더니 다음과 같았습니다:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>9.8, 10.2, 10.0, 9.9, 10.1, 9.7, 10.3, 10.0, 9.8, 10.2 (단위: cm)
</code></pre></div> </div> </li> </ul> <p><strong>질문</strong>:</p> <ul> <li>이 데이터를 바탕으로 부품 길이의 평균(μ)과 표준편차(σ)를 우도를 이용하여 추정할 수 있을까요?</li> </ul> <p><strong>분석</strong>:</p> <ol> <li> <p><strong>우도함수(Likelihood Function) 정의</strong>:</p> <p>관찰된 데이터가 주어졌을 때, μ와 σ에 대한 우도함수는 다음과 같습니다.</p> </li> </ol> \[L(\mu, \sigma) = \prod_{i=1}^{n} f(x_i | \mu, \sigma)\] <table> <tbody> <tr> <td>여기서$f(x_i</td> <td>\mu, \sigma)$는 정규분포의 확률밀도함수입니다.</td> </tr> </tbody> </table> <ol> <li><strong>정규분포의 확률밀도함수</strong>:</li> </ol> \[f(x | \mu, \sigma) = \frac{1}{\sqrt{2\pi \sigma^2}} \exp\left( -\frac{(x - \mu)^2}{2\sigma^2} \right)\] <ol> <li> <p><strong>로그우도함수(Log-Likelihood Function)</strong>:</p> <p>우도함수의 로그를 취하면 계산이 용이해집니다.</p> </li> </ol> \[\ln L(\mu, \sigma) = -n \ln \sigma - \frac{n}{2} \ln(2\pi) - \frac{1}{2\sigma^2} \sum_{i=1}^{n} (x_i - \mu)^2\] <ol> <li> <p><strong>최대우도추정(MLE) 계산</strong>:</p> <p>로그우도함수를 μ와 σ에 대해 편미분하고, 이를 0으로 놓아 μ와 σ의 추정치를 구합니다.</p> <ul> <li>μ에 대한 편미분:</li> </ul> </li> </ol> \[\frac{\partial \ln L}{\partial \mu} = \frac{1}{\sigma^2} \sum_{i=1}^{n} (x_i - \mu) = 0\] <p>이를 풀면:</p> \[\mu = \frac{1}{n} \sum_{i=1}^{n} x_i\] <ul> <li>σ에 대한 편미분:</li> </ul> \[\frac{\partial \ln L}{\partial \sigma} = -\frac{n}{\sigma} + \frac{1}{\sigma^3} \sum_{i=1}^{n} (x_i - \mu)^2 = 0\] <p>이를 풀면:</p> \[\sigma^2 = \frac{1}{n} \sum_{i=1}^{n} (x_i - \mu)^2\] <ol> <li> <p><strong>계산 결과</strong>:</p> <ul> <li>μ의 추정치:</li> </ul> </li> </ol> \[\mu = \frac{1}{10} (9.8 + 10.2 + 10.0 + 9.9 + 10.1 + 9.7 + 10.3 + 10.0 + 9.8 + 10.2) = 10.0 \, \text{cm}\] <ul> <li>σ의 추정치:</li> </ul> <p>먼저 각 데이터와 평균의 차이의 제곱을 구합니다.</p> \[\sum_{i=1}^{n} (x_i - \mu)^2 = (9.8 - 10.0)^2 + (10.2 - 10.0)^2 + \ldots + (10.2 - 10.0)^2 = 0.82\] <p>따라서,</p> <p>\(\sigma^2 = \frac{0.82}{10} = 0.082 \quad \Rightarrow \quad \sigma = \sqrt{0.082} \approx 0.286 \, \text{cm}\) <strong>결론</strong>:</p> <ul> <li>우도를 최대화하는 평균 μ의 추정치는 <strong>10.0 cm</strong>입니다.</li> <li>우도를 최대화하는 표준편차 σ의 추정치는 <strong>약 0.286 cm</strong>입니다.</li> <li>이는 관찰된 데이터를 가장 잘 설명하는 정규분포의 모수 추정치입니다.</li> </ul> <h3 id="추가로-살펴보는-예시-로그우도와-회귀분석">추가로 살펴보는 예시: 로그우도와 회귀분석</h3> <p><strong>상황</strong>:</p> <ul> <li>연구자가 광고 비용과 판매량 간의 관계를 분석하고자 합니다.</li> <li>다음과 같은 데이터가 있습니다.</li> </ul> <table> <thead> <tr> <th>광고 비용 (만원)</th> <th>판매량 (단위)</th> </tr> </thead> <tbody> <tr> <td>10</td> <td>15</td> </tr> <tr> <td>15</td> <td>20</td> </tr> <tr> <td>20</td> <td>25</td> </tr> <tr> <td>25</td> <td>30</td> </tr> <tr> <td>30</td> <td>29</td> </tr> </tbody> </table> <p><strong>질문</strong>:</p> <ul> <li>광고 비용과 판매량 사이의 선형 관계를 가정하고, 우도를 이용하여 회귀 계수들을 추정할 수 있을까요?</li> </ul> <p><strong>분석</strong>:</p> <ol> <li><strong>모델 설정</strong>:</li> </ol> <p>선형 회귀 모델을 설정합니다.</p> \[y_i = \beta_0 + \beta_1 x_i + \epsilon_i\] <p>여기서$\epsilon_i$는 평균이 0이고 분산이$\sigma^2$인 정규분포를 따릅니다.</p> <ol> <li><strong>우도함수 정의</strong>:</li> </ol> <p>각$y_i$는 정규분포를 따르므로 우도함수는 다음과 같습니다.</p> \[L(\beta_0, \beta_1, \sigma^2) = \prod_{i=1}^{n} \frac{1}{\sqrt{2\pi \sigma^2}} \exp\left( -\frac{(y_i - \beta_0 - \beta_1 x_i)^2}{2\sigma^2} \right)\] <ol> <li><strong>로그우도함수</strong>:</li> </ol> \[\ln L = -\frac{n}{2} \ln(2\pi \sigma^2) - \frac{1}{2\sigma^2} \sum_{i=1}^{n} (y_i - \beta_0 - \beta_1 x_i)^2\] <ol> <li><strong>최대우도추정(MLE) 계산</strong>:</li> </ol> <ul> <li>로그우도함수를$\beta_0$와$\beta_1$에 대해 편미분하고 0으로 놓습니다.</li> <li>이는 최소제곱법과 동일한 결과를 가져옵니다.</li> </ul> <ol> <li><strong>계산 과정</strong>:</li> </ol> <p>최소제곱법을 이용하여 회귀 계수를 추정합니다.</p> <p>-$\beta_1$의 추정치:</p> \[\beta_1 = \frac{\sum (x_i - \bar{x})(y_i - \bar{y})}{\sum (x_i - \bar{x})^2}\] <p>-$\beta_0$의 추정치:</p> \[\beta_0 = \bar{y} - \beta_1 \bar{x}\] <p>계산을 수행하면:</p> <p>-$\bar{x} = \frac{10 + 15 + 20 + 25 + 30}{5} = 20$ -$\bar{y} = \frac{15 + 20 + 25 + 30 + 29}{5} = 23.8$</p> <ul> <li>분자:</li> </ul> \[\sum (x_i - \bar{x})(y_i - \bar{y}) = (10 - 20)(15 - 23.8) + \ldots + (30 - 20)(29 - 23.8) = 200\] <ul> <li>분모:</li> </ul> \[\sum (x_i - \bar{x})^2 = (10 - 20)^2 + \ldots + (30 - 20)^2 = 500\] <p>따라서,</p> <p>-$\beta_1 = \frac{200}{500} = 0.4$ -$\beta_0 = 23.8 - 0.4 \times 20 = 15.8$</p> <p><strong>결론</strong>:</p> <ul> <li>우도를 최대화하는 회귀 계수의 추정치는$\beta_0 = 15.8$,$\beta_1 = 0.4$입니다.</li> <li>이는 광고 비용이 1만 원 증가할 때마다 판매량이 0.4 단위 증가함을 의미합니다.</li> <li>우도를 이용한 추정은 최소제곱법과 동일한 결과를 가져옵니다.</li> </ul> <h2 id="우도-비율-검정likelihood-ratio-test를-통한-모델-비교">우도 비율 검정(Likelihood Ratio Test)를 통한 모델 비교</h2> <p><strong>상황</strong>:</p> <ul> <li>두 개의 모델을 비교하고자 합니다. <ul> <li><strong>모델 1(제한된 모델)</strong>: 광고 비용과 판매량 사이에 관계가 없다. ($\beta_1 = 0$)</li> <li><strong>모델 2(전체 모델)</strong>: 광고 비용과 판매량 사이에 선형 관계가 있다.</li> </ul> </li> </ul> <p><strong>질문</strong>:</p> <ul> <li>우도 비율 검정을 통해 두 모델 중 어떤 모델이 데이터를 더 잘 설명하는지 판단할 수 있을까요?</li> </ul> <p><strong>분석</strong>:</p> <ol> <li> <p><strong>우도 계산</strong>:</p> <ul> <li><strong>모델 1의 우도(L₁)</strong>:$\beta_1 = 0$로 설정하여 우도를 계산합니다.</li> <li><strong>모델 2의 우도(L₂)</strong>: 이전에 계산한$\beta_0$와$\beta_1$를 사용하여 우도를 계산합니다.</li> </ul> </li> <li> <p><strong>우도 비율 통계량(Lambda)</strong>:</p> </li> </ol> \[\Lambda = -2 \ln\left( \frac{L₁}{L₂} \right)\] <p>이 통계량은 카이제곱 분포를 따릅니다.</p> <ol> <li> <p><strong>검정</strong>:</p> <ul> <li>유의수준(예: 0.05)을 설정합니다.</li> <li>자유도는 제한된 모형과 전체 모형의 모수 차이입니다. 여기서는 1입니다.</li> <li>계산된$\Lambda$ 값과 카이제곱 분포의 임계값을 비교합니다.</li> </ul> </li> <li> <p><strong>결과 해석</strong>:</p> <p>-$\Lambda$가 임계값보다 크면, 모델 2가 더 적합하다고 판단합니다.</p> <ul> <li>그렇지 않으면, 모델 1을 채택합니다.</li> </ul> </li> </ol> <p><strong>결론</strong>:</p> <ul> <li>우도 비율 검정을 통해 광고 비용이 판매량에 유의한 영향을 미치는지 통계적으로 검증할 수 있습니다.</li> <li>이 방법은 모델의 복잡성을 고려하면서 데이터에 대한 적합성을 평가하는 데 유용합니다.</li> </ul>]]></content><author><name></name></author><category term="통계학"/><category term="likelihood"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">Git과 GitHub는 뭐가 다를까( 초보자를 위한 쉬운 설명)</title><link href="https://chanp5660.github.io/blog/2024/Git%EA%B3%BC-GitHub%EB%8A%94-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%BC%EA%B9%8C(-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%89%AC%EC%9A%B4-%EC%84%A4%EB%AA%85)/" rel="alternate" type="text/html" title="Git과 GitHub는 뭐가 다를까( 초보자를 위한 쉬운 설명)"/><published>2024-10-17T00:00:00+00:00</published><updated>2024-10-17T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/Git%EA%B3%BC-GitHub%EB%8A%94-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%BC%EA%B9%8C(-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%89%AC%EC%9A%B4-%EC%84%A4%EB%AA%85)</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/Git%EA%B3%BC-GitHub%EB%8A%94-%EB%AD%90%EA%B0%80-%EB%8B%A4%EB%A5%BC%EA%B9%8C(-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%89%AC%EC%9A%B4-%EC%84%A4%EB%AA%85)/"><![CDATA[<p>연결 문서</p> <h1 id="git과-github는-뭐가-다를까-초보자를-위한-쉬운-설명">Git과 GitHub는 뭐가 다를까( 초보자를 위한 쉬운 설명)</h1> <p>프로그래밍을 시작하면서 <strong>Git</strong>과 <strong>GitHub</strong>라는 용어를 많이 들어보셨을 거예요. 이 두 가지가 어떻게 다른지 헷갈릴 수 있는데요. 오늘은 초보자분들을 위해 Git과 GitHub의 차이점을 항목별로 자세히 설명해드리겠습니다.</p> <h2 id="비유를-통한-이해">비유를 통한 이해</h2> <ul> <li><strong>Git은</strong> 개인 컴퓨터에서 <strong>문서의 변경 이력을 관리하는 도구</strong>입니다. <ul> <li>예를 들어, 책을 쓰면서 각 장의 수정 내용을 기록하고 싶을 때 사용합니다.</li> </ul> </li> <li><strong>GitHub는</strong> 이 문서를 <strong>온라인에 업로드하고 다른 사람들과 함께 편집하는 플랫폼</strong>입니다. <ul> <li>공동 저자들과 함께 책을 쓰면서 수정 내용을 공유하고 의견을 나눌 수 있습니다.</li> </ul> </li> </ul> <hr/> <h2 id="git이란-무엇인가">Git이란 무엇인가?</h2> <p><strong>Git은 분산 버전 관리 시스템(DVCS)입니다.</strong></p> <h3 id="버전-관리-시스템vcs이란">버전 관리 시스템(VCS)이란?</h3> <ul> <li>파일의 변경 이력을 기록하고 관리하는 시스템입니다.</li> <li>여러 명이 동시에 작업해도 충돌 없이 파일을 관리할 수 있습니다.</li> <li>언제든지 이전 버전으로 되돌아갈 수 있습니다.</li> </ul> <h3 id="git의-주요-특징">Git의 주요 특징</h3> <ul> <li><strong>분산형 구조</strong>: 중앙 서버가 없어도 로컬에서 모든 작업이 가능합니다.</li> <li><strong>빠른 성능</strong>: 대부분의 작업이 로컬에서 이루어져 속도가 빠릅니다.</li> <li><strong>강력한 브랜칭과 머징</strong>: 다양한 브랜치를 만들어 실험하고, 필요할 때 합칠 수 있습니다.</li> </ul> <h3 id="git의-주요-명령어">Git의 주요 명령어</h3> <ul> <li><code class="language-plaintext highlighter-rouge">git init</code>: 새로운 Git 저장소를 생성합니다.</li> <li><code class="language-plaintext highlighter-rouge">git add</code>: 변경된 파일을 스테이지에 추가합니다.</li> <li><code class="language-plaintext highlighter-rouge">git commit</code>: 스테이지에 있는 파일들을 커밋합니다.</li> <li><code class="language-plaintext highlighter-rouge">git push</code>: 로컬 커밋을 원격 저장소에 업로드합니다.</li> <li><code class="language-plaintext highlighter-rouge">git pull</code>: 원격 저장소의 변경 사항을 로컬에 가져옵니다.</li> </ul> <hr/> <h2 id="github란-무엇인가">GitHub란 무엇인가?</h2> <p><strong>GitHub는 Git 저장소를 호스팅하는 웹 기반 플랫폼입니다.</strong></p> <h3 id="github의-주요-역할">GitHub의 주요 역할</h3> <ul> <li><strong>원격 저장소 제공</strong>: 인터넷 상에서 Git 저장소를 저장하고 관리할 수 있습니다.</li> <li><strong>협업 기능 지원</strong>: 여러 개발자들이 함께 프로젝트를 진행할 수 있도록 도와줍니다.</li> <li><strong>프로젝트 관리 도구</strong>: 이슈 트래킹, 코드 리뷰, 위키 등 다양한 도구를 제공합니다.</li> </ul> <h3 id="github의-주요-기능">GitHub의 주요 기능</h3> <ul> <li><strong>리포지토리(Repository)</strong>: 프로젝트의 파일과 변경 이력을 저장하는 공간입니다.</li> <li><strong>이슈(Issue)</strong>: 버그 리포트나 기능 개선 요청 등을 관리합니다.</li> <li><strong>풀 리퀘스트(Pull Request)</strong>: 코드 변경 사항을 검토하고 병합할 수 있습니다.</li> <li><strong>액션(Actions)</strong>: CI/CD 파이프라인을 구축하여 자동화된 작업을 실행합니다.</li> </ul> <h3 id="github의-추가-기능">GitHub의 추가 기능</h3> <ul> <li><strong>GitHub Pages</strong>: 리포지토리를 통해 정적 웹사이트를 호스팅할 수 있습니다.</li> <li><strong>GitHub Gist</strong>: 간단한 스니펫이나 메모를 공유할 수 있습니다.</li> <li><strong>커뮤니티 참여</strong>: 오픈 소스 프로젝트에 기여하고 다른 개발자들과 소통할 수 있습니다.</li> </ul> <hr/> <h2 id="git과-github의-차이점">Git과 GitHub의 차이점</h2> <table> <thead> <tr> <th><strong>항목</strong></th> <th><strong>Git</strong></th> <th><strong>GitHub</strong></th> </tr> </thead> <tbody> <tr> <td><strong>정의</strong></td> <td>분산 버전 관리 시스템</td> <td>Git 저장소를 호스팅하는 웹 기반 플랫폼</td> </tr> <tr> <td><strong>역할</strong></td> <td>로컬에서 파일의 변경 이력을 관리하고 버전 컨트롤을 수행</td> <td>원격 저장소를 제공하고 협업 및 프로젝트 관리를 지원</td> </tr> <tr> <td><strong>사용 방법</strong></td> <td>명령줄 인터페이스(CLI)나 GUI 도구를 통해 로컬에서 사용</td> <td>웹 브라우저나 Git 클라이언트를 통해 온라인에서 사용</td> </tr> <tr> <td><strong>주요 기능</strong></td> <td>커밋, 브랜치, 머지 등의 버전 관리 기능 제공</td> <td>이슈 관리, 풀 리퀘스트, 코드 리뷰 등의 협업 기능 제공</td> </tr> <tr> <td><strong>필요성</strong></td> <td>버전 관리를 위해 필수적</td> <td>협업과 원격 저장소 관리에 유용하지만 필수는 아님</td> </tr> <tr> <td><strong>접근성</strong></td> <td>로컬 컴퓨터에서 오프라인으로도 사용 가능</td> <td>인터넷 연결이 필요</td> </tr> </tbody> </table> <hr/> <h2 id="git과-github의-관계">Git과 GitHub의 관계</h2> <ul> <li><strong>독립적 사용 가능</strong>: <ul> <li>Git은 로컬에서 혼자서도 사용할 수 있습니다.</li> <li>GitHub는 Git 없이도 코드나 파일을 업로드할 수 있지만, Git과 함께 사용할 때 더 강력합니다.</li> </ul> </li> <li><strong>함께 사용 시 시너지 효과</strong>: <ul> <li>Git으로 로컬에서 버전 관리를 하고, GitHub를 통해 변경 사항을 공유하고 협업할 수 있습니다.</li> <li>팀 프로젝트나 오픈 소스 프로젝트에서 많이 사용하는 방식입니다.</li> </ul> </li> </ul> <hr/> <h2 id="실제-사용-예시">실제 사용 예시</h2> <ol> <li><strong>프로젝트 시작</strong>: <ul> <li>로컬에서 <code class="language-plaintext highlighter-rouge">git init</code>으로 새로운 Git 저장소를 생성합니다.</li> </ul> </li> <li><strong>코드 작성 및 커밋</strong>: <ul> <li>파일을 수정하고 <code class="language-plaintext highlighter-rouge">git add</code>와 <code class="language-plaintext highlighter-rouge">git commit</code>으로 변경 사항을 기록합니다.</li> </ul> </li> <li><strong>GitHub에 원격 저장소 생성</strong>: <ul> <li>GitHub 웹사이트에서 새로운 리포지토리를 만듭니다.</li> </ul> </li> <li><strong>로컬과 원격 연결</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">git remote add origin [원격 저장소 URL]</code>로 연결합니다.</li> </ul> </li> <li><strong>변경 사항 푸시(Push)</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">git push -u origin main</code>으로 로컬 커밋을 GitHub에 업로드합니다.</li> </ul> </li> <li><strong>팀원들과 협업</strong>: <ul> <li>다른 개발자들이 리포지토리를 클론(clone)하여 함께 작업합니다.</li> <li>풀 리퀘스트와 이슈를 통해 코드 리뷰와 버그 수정을 진행합니다.</li> </ul> </li> </ol> <hr/> <h2 id="요약-및-마무리">요약 및 마무리</h2> <ul> <li><strong>Git은</strong> 로컬에서 파일의 버전 관리를 담당하는 <strong>도구</strong>입니다.</li> <li><strong>GitHub는</strong> Git 저장소를 온라인에서 호스팅하고 협업을 지원하는 <strong>플랫폼</strong>입니다.</li> <li>둘은 함께 사용되며, Git으로 버전 관리를 하고 GitHub로 협업과 원격 저장소 관리를 합니다.</li> </ul> <hr/> <h2 id="추가로-알아두면-좋은-것들">추가로 알아두면 좋은 것들</h2> <ul> <li><strong>다른 Git 호스팅 서비스</strong>: GitHub 외에도 GitLab, Bitbucket 등이 있습니다.</li> <li><strong>GUI 클라이언트</strong>: 명령줄이 어렵다면 Sourcetree, GitKraken 등의 GUI 도구를 사용할 수 있습니다.</li> <li><strong>학습 자료</strong>: <ul> <li>Git 공식 문서: <a href="https://git-scm.com/doc">https://git-scm.com/doc</a></li> <li>GitHub 가이드: <a href="https://guides.github.com/">https://guides.github.com/</a></li> </ul> </li> </ul>]]></content><author><name></name></author><category term="git/github"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">특정 커밋으로 돌아가는 방법</title><link href="https://chanp5660.github.io/blog/2024/%ED%8A%B9%EC%A0%95-%EC%BB%A4%EB%B0%8B%EC%9C%BC%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EB%B0%A9%EB%B2%95/" rel="alternate" type="text/html" title="특정 커밋으로 돌아가는 방법"/><published>2024-10-17T00:00:00+00:00</published><updated>2024-10-17T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/%ED%8A%B9%EC%A0%95-%EC%BB%A4%EB%B0%8B%EC%9C%BC%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EB%B0%A9%EB%B2%95</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/%ED%8A%B9%EC%A0%95-%EC%BB%A4%EB%B0%8B%EC%9C%BC%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EB%B0%A9%EB%B2%95/"><![CDATA[<p>연결 문서</p> <h1 id="특정-커밋으로-돌아가는-방법">특정 커밋으로 돌아가는 방법</h1> <p>특정 커밋으로 돌아가는 방법은 <code class="language-plaintext highlighter-rouge">git checkout</code> 또는 <code class="language-plaintext highlighter-rouge">git reset</code> 명령어를 사용하여 할 수 있음. 아래는 두 가지 방법을 설명함.</p> <h2 id="git-checkout">git checkout</h2> <p>특정 커밋의 상태로 프로젝트를 잠시 돌아가서 확인하거나 작업하려면 <code class="language-plaintext highlighter-rouge">git checkout</code>을 사용함. 이는 임시로 커밋 상태를 확인할 때 사용하며, 새로운 브랜치를 생성할 수도 있음.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout &lt;commit_hash&gt;
</code></pre></div></div> <p>다시 원래 브랜치로 돌아가려면:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout main  <span class="c"># 또는 원래 작업하던 브랜치 이름</span>
</code></pre></div></div> <h2 id="git-reset">git reset</h2> <p>프로젝트의 히스토리를 수정하고 특정 커밋으로 돌아가고 싶다면 <code class="language-plaintext highlighter-rouge">git reset</code>을 사용함. 이 경우, 이후의 커밋들은 사라지게 됨.</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">--hard</code> 옵션</strong>: 작업 중인 파일도 함께 되돌아감.</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--hard</span> &lt;commit_hash&gt;
</code></pre></div></div> <ul> <li><strong><code class="language-plaintext highlighter-rouge">--soft</code> 옵션</strong>: 커밋만 되돌리고, 작업 중인 파일은 그대로 남김.</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git reset <span class="nt">--soft</span> &lt;commit_hash&gt;
</code></pre></div></div> <ul> <li><a href="https://chanp5660.github.io/blog/2024/push-된-commit-복원하여-현재-상태-적용하기/">push 된 commit 복원하여 현재 상태 적용하기</a> : 현재 상태를 저장소에 저장</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">--force</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="git"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">python 에서 데코레이터</title><link href="https://chanp5660.github.io/blog/2024/python-%EC%97%90%EC%84%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/" rel="alternate" type="text/html" title="python 에서 데코레이터"/><published>2024-10-17T00:00:00+00:00</published><updated>2024-10-17T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/python-%EC%97%90%EC%84%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/python-%EC%97%90%EC%84%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0/"><![CDATA[<p>연결 문서</p> <h1 id="python-에서-데코레이터">python 에서 데코레이터</h1> <h2 id="데코레이터란-무엇인가">데코레이터란 무엇인가?</h2> <p>데코레이터는 <strong>함수에 새로운 기능을 추가하는 도구</strong>임. 마치 선물을 포장지로 감싸는 것처럼, 함수에 데코레이터를 적용하면 그 함수에 부가적인 기능을 덧붙일 수 있음.</p> <h2 id="왜-데코레이터를-사용할까">왜 데코레이터를 사용할까?</h2> <ul> <li><strong>코드 재사용성 증가:</strong> 반복되는 코드를 줄일 수 있음.</li> <li><strong>코드 가독성 향상:</strong> 핵심 기능과 부가 기능을 분리하여 코드가 깔끔해짐.</li> <li><strong>유지 보수 용이:</strong> 한 곳에서 부가 기능을 관리할 수 있어 수정이 쉬워짐.</li> </ul> <h2 id="데코레이터를-현실에-비유하기--카페에서-주문하기">데코레이터를 현실에 비유하기 : 카페에서 주문하기</h2> <p>데코레이터를 이해하기 어려울 수 있으니, 현실적인 예로 비유해보겠음.</p> <ul> <li>당신이 커피를 주문한다고 가정해보겠음.</li> <li>기본적으로 커피는 에스프레소 샷으로 만들어짐.</li> <li>여기에 <strong>시럽 추가</strong>나 <strong>휘핑크림 추가</strong> 등의 옵션을 더할 수 있음.</li> </ul> <p>여기서 <strong>에스프레소</strong>는 기본 함수이고, <strong>시럽 추가</strong>나 <strong>휘핑크림 추가</strong>는 데코레이터와 같음.</p> <h2 id="간단한-예제로-이해하기">간단한 예제로 이해하기</h2> <h3 id="예제-1--카페에서-주문하기">예제 1 : 카페에서 주문하기</h3> <h4 id="기본-함수-만들기">기본 함수 만들기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">커피</span><span class="p">():</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">에스프레소</span><span class="sh">"</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">커피()</code> 함수를 호출하면 “에스프레소”를 반환함.</p> <h4 id="시럽-추가-데코레이터-만들기">시럽 추가 데코레이터 만들기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">시럽_추가</span><span class="p">(</span><span class="n">함수</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="n">결과</span> <span class="o">=</span> <span class="n">함수</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">결과</span> <span class="o">+</span> <span class="sh">"</span><span class="s"> + 시럽</span><span class="sh">"</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">시럽_추가</code> 데코레이터는 커피에 시럽을 추가함.</p> <h4 id="휘핑크림-추가-데코레이터-만들기">휘핑크림 추가 데코레이터 만들기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">휘핑크림_추가</span><span class="p">(</span><span class="n">함수</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="n">결과</span> <span class="o">=</span> <span class="n">함수</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">결과</span> <span class="o">+</span> <span class="sh">"</span><span class="s"> + 휘핑크림</span><span class="sh">"</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">휘핑크림_추가</code> 데코레이터는 커피에 휘핑크림을 추가함.</p> <h4 id="데코레이터-적용하기">데코레이터 적용하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@시럽_추가</span>
<span class="k">def</span> <span class="nf">커피</span><span class="p">():</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">에스프레소</span><span class="sh">"</span>
</code></pre></div></div> <p>이렇게 하면 <code class="language-plaintext highlighter-rouge">커피()</code> 함수를 호출할 때 시럽이 추가됨.</p> <h4 id="결과-확인하기">결과 확인하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">주문</span> <span class="o">=</span> <span class="n">커피</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">주문</span><span class="p">)</span>
</code></pre></div></div> <p><strong>출력:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>에스프레소 + 시럽
</code></pre></div></div> <h4 id="여러-데코레이터-적용하기">여러 데코레이터 적용하기</h4> <p>데코레이터는 여러 개를 적용할 수 있음.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@휘핑크림_추가</span>
<span class="nd">@시럽_추가</span>
<span class="k">def</span> <span class="nf">커피</span><span class="p">():</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">에스프레소</span><span class="sh">"</span>
</code></pre></div></div> <p>이렇게 하면 <code class="language-plaintext highlighter-rouge">커피()</code> 함수에 시럽과 휘핑크림이 모두 추가됨.</p> <h4 id="결과-확인하기-1">결과 확인하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">주문</span> <span class="o">=</span> <span class="n">커피</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">주문</span><span class="p">)</span>
</code></pre></div></div> <p><strong>출력:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>에스프레소 + 시럽 + 휘핑크림
</code></pre></div></div> <h3 id="예제-2--간단한-인사하기">예제 2 : 간단한 인사하기</h3> <h4 id="기본-함수-만들기-1">기본 함수 만들기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">인사</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">안녕하세요!</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">인사()</code> 함수를 호출하면 “안녕하세요!”가 출력됨.</p> <h4 id="함수에-부가-기능-추가하기-데코레이터-없이">함수에 부가 기능 추가하기 (데코레이터 없이)</h4> <p>함수가 호출될 때마다 로그를 출력하고 싶음.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">인사</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">인사 함수가 호출되었음</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">안녕하세요!</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>하지만 이런 방식은 함수마다 코드를 추가해야 해서 비효율적임.</p> <h4 id="데코레이터-만들기">데코레이터 만들기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">로그_데코레이터</span><span class="p">(</span><span class="n">함수</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">함수</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> 함수가 호출되었음</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">함수</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">로그_데코레이터</code>는 함수 호출 전에 로그를 출력해주는 데코레이터임.</p> <h4 id="데코레이터-적용하기-1">데코레이터 적용하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@로그_데코레이터</span>
<span class="k">def</span> <span class="nf">인사</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">안녕하세요!</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">@로그_데코레이터</code>를 사용하여 <code class="language-plaintext highlighter-rouge">인사</code> 함수에 로그 기능을 추가했음.</p> <h4 id="결과-확인하기-2">결과 확인하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">인사</span><span class="p">()</span>
</code></pre></div></div> <p><strong>출력:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>인사 함수가 호출되었음
안녕하세요!
</code></pre></div></div> <p>함수 내부 코드를 수정하지 않고도 로그 기능을 추가했음.</p> <h3 id="조금-더-복잡한-예제--실행-시간-측정">조금 더 복잡한 예제 : 실행 시간 측정</h3> <h4 id="실행-시간-측정-데코레이터-만들기">실행 시간 측정 데코레이터 만들기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>

<span class="k">def</span> <span class="nf">실행시간_데코레이터</span><span class="p">(</span><span class="n">함수</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="n">시작시간</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">함수</span><span class="p">()</span>
        <span class="n">종료시간</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">실행 시간: </span><span class="si">{</span><span class="n">종료시간</span> <span class="o">-</span> <span class="n">시작시간</span><span class="si">}</span><span class="s">초</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div> <h4 id="데코레이터-적용하기-2">데코레이터 적용하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@실행시간_데코레이터</span>
<span class="k">def</span> <span class="nf">느린_함수</span><span class="p">():</span>
    <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">작업 완료!</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <h4 id="결과-확인하기-3">결과 확인하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">느린_함수</span><span class="p">()</span>
</code></pre></div></div> <p><strong>출력:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>작업 완료!
실행 시간: 2.002초
</code></pre></div></div> <p>함수의 실행 시간을 자동으로 측정해줌.</p> <h3 id="또-다른-예제-로그인-확인-데코레이터">또 다른 예제: 로그인 확인 데코레이터</h3> <p>웹 애플리케이션에서 사용자 로그인 여부를 확인하는 기능을 데코레이터로 만들어보겠음.</p> <h4 id="로그인-확인-데코레이터-만들기">로그인 확인 데코레이터 만들기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">로그인_확인</span><span class="p">(</span><span class="n">함수</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">user</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">user</span><span class="p">[</span><span class="sh">'</span><span class="s">로그인</span><span class="sh">'</span><span class="p">]:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">로그인이 필요합니다.</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="n">함수</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div> <h4 id="데코레이터-적용하기-3">데코레이터 적용하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@로그인_확인</span>
<span class="k">def</span> <span class="nf">프로필_보기</span><span class="p">(</span><span class="n">user</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">user</span><span class="p">[</span><span class="sh">'</span><span class="s">이름</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">님의 프로필입니다.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <h4 id="사용자-데이터-예시">사용자 데이터 예시</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">사용자1</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">이름</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">철수</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">로그인</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
<span class="n">사용자2</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">이름</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">영희</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">로그인</span><span class="sh">'</span><span class="p">:</span> <span class="bp">False</span><span class="p">}</span>
</code></pre></div></div> <h4 id="결과-확인하기-4">결과 확인하기</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">프로필_보기</span><span class="p">(</span><span class="n">사용자1</span><span class="p">)</span>
<span class="c1"># 출력: 철수님의 프로필입니다.
</span>
<span class="n">프로필_보기</span><span class="p">(</span><span class="n">사용자2</span><span class="p">)</span>
<span class="c1"># 출력: 로그인이 필요합니다.
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">프로필_보기</code> 함수를 호출할 때 로그인 여부를 자동으로 확인함.</p> <h2 id="데코레이터의-동작-원리-이해하기">데코레이터의 동작 원리 이해하기</h2> <p>데코레이터는 <strong>함수를 입력으로 받아 또 다른 함수를 반환하는 함수</strong>임.</p> <h3 id="데코레이터-함수-구조">데코레이터 함수 구조</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">데코레이터</span><span class="p">(</span><span class="n">함수</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="c1"># 부가 기능 추가
</span>        <span class="n">결과</span> <span class="o">=</span> <span class="n">함수</span><span class="p">()</span>
        <span class="c1"># 부가 기능 추가
</span>        <span class="k">return</span> <span class="n">결과</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">데코레이터</code> 함수는 <code class="language-plaintext highlighter-rouge">함수</code>를 입력으로 받음.</li> <li><code class="language-plaintext highlighter-rouge">wrapper</code> 함수 안에서 원본 함수를 호출하고 결과를 반환함.</li> <li><code class="language-plaintext highlighter-rouge">데코레이터</code> 함수는 <code class="language-plaintext highlighter-rouge">wrapper</code> 함수를 반환함.</li> </ul> <h3 id="데코레이터-적용-과정">데코레이터 적용 과정</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@데코레이터</span>
<span class="k">def</span> <span class="nf">원본_함수</span><span class="p">():</span>
    <span class="k">pass</span>
</code></pre></div></div> <p>이 코드는 다음과 동일함.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">원본_함수</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">원본_함수</span> <span class="o">=</span> <span class="n">데코레이터</span><span class="p">(</span><span class="n">원본_함수</span><span class="p">)</span>
</code></pre></div></div> <p>즉, 원본 함수가 데코레이터 함수에 의해 감싸여서 새로운 함수로 대체됨.</p> <h2 id="여러-인자를-가진-함수에-데코레이터-적용하기">여러 인자를 가진 함수에 데코레이터 적용하기</h2> <p>인자를 가진 함수에도 데코레이터를 적용하려면 <code class="language-plaintext highlighter-rouge">*args</code>와 <code class="language-plaintext highlighter-rouge">**kwargs</code>를 사용하면 됨.</p> <h3 id="데코레이터-수정하기">데코레이터 수정하기</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">로그_데코레이터</span><span class="p">(</span><span class="n">함수</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">함수</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s"> 함수가 호출되었음</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">함수</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</code></pre></div></div> <h3 id="인자를-가진-함수에-적용하기">인자를 가진 함수에 적용하기</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@로그_데코레이터</span>
<span class="k">def</span> <span class="nf">덧셈</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">결과</span> <span class="o">=</span> <span class="n">덧셈</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">결과: </span><span class="si">{</span><span class="n">결과</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p><strong>출력:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>덧셈 함수가 호출되었음
결과: 8
</code></pre></div></div> <h2 id="정리하며">정리하며</h2> <ul> <li>데코레이터는 함수에 부가적인 기능을 쉽게 추가할 수 있게 해주는 도구임.</li> <li><code class="language-plaintext highlighter-rouge">@데코레이터_이름</code>을 사용하여 간단하게 적용할 수 있음.</li> <li>부가 기능을 별도의 함수로 분리하여 코드의 재사용성과 가독성을 높일 수 있음.</li> </ul> <h2 id="마치며">마치며</h2> <p>처음에는 데코레이터가 어려워 보일 수 있지만, 예제를 따라 해보면서 이해하면 큰 도움이 될 것임. 직접 다양한 데코레이터를 만들어보고 적용해보면서 파이썬의 강력한 기능을 활용해보길 바람.</p>]]></content><author><name></name></author><category term="python"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">생성형 AI 모델 총정리( 내가 사용하고 있는 모델부터 최신 모델까지)</title><link href="https://chanp5660.github.io/blog/2024/%EC%83%9D%EC%84%B1%ED%98%95-AI-%EB%AA%A8%EB%8D%B8-%EC%B4%9D%EC%A0%95%EB%A6%AC(-%EB%82%B4%EA%B0%80-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%AA%A8%EB%8D%B8%EB%B6%80%ED%84%B0-%EC%B5%9C%EC%8B%A0-%EB%AA%A8%EB%8D%B8%EA%B9%8C%EC%A7%80)/" rel="alternate" type="text/html" title="생성형 AI 모델 총정리( 내가 사용하고 있는 모델부터 최신 모델까지)"/><published>2024-10-15T00:00:00+00:00</published><updated>2024-10-15T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/%EC%83%9D%EC%84%B1%ED%98%95-AI-%EB%AA%A8%EB%8D%B8-%EC%B4%9D%EC%A0%95%EB%A6%AC(-%EB%82%B4%EA%B0%80-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%AA%A8%EB%8D%B8%EB%B6%80%ED%84%B0-%EC%B5%9C%EC%8B%A0-%EB%AA%A8%EB%8D%B8%EA%B9%8C%EC%A7%80)</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/%EC%83%9D%EC%84%B1%ED%98%95-AI-%EB%AA%A8%EB%8D%B8-%EC%B4%9D%EC%A0%95%EB%A6%AC(-%EB%82%B4%EA%B0%80-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%AA%A8%EB%8D%B8%EB%B6%80%ED%84%B0-%EC%B5%9C%EC%8B%A0-%EB%AA%A8%EB%8D%B8%EA%B9%8C%EC%A7%80)/"><![CDATA[<p>연결 문서</p> <h1 id="생성형-ai-모델-총정리-내가-사용하고-있는-모델부터-최신-모델까지">생성형 AI 모델 총정리( 내가 사용하고 있는 모델부터 최신 모델까지)</h1> <p>인공지능 기술의 발전으로 생성형 AI 모델이 다양한 분야에서 활용되고 있습니다. 이번 글에서는 제가 현재 사용하고 있는 생성형 AI 모델부터 최신에 출시된 모델까지 특징별로 정리해보려고 합니다.</p> <h2 id="대화형-ai-모델">대화형 AI 모델</h2> <h3 id="chatgpt">ChatGPT</h3> <ul> <li><strong>개발사</strong>: OpenAI, <a href="https://chatgpt.com/">ChatGPT</a></li> <li><strong>특징</strong>: GPT-4 아키텍처를 기반으로 한 대화형 AI 모델로, 자연스러운 언어 이해와 생성 능력을 갖추고 있습니다. 다양한 주제에 대한 질문에 답변하고, 창의적인 글 작성, 코드 생성, 데이터 분석 등 광범위한 작업을 수행할 수 있습니다. 최근에는 이미지 처리 및 음성 인식 기능도 추가되었습니다.</li> </ul> <h3 id="claude">Claude</h3> <ul> <li><strong>개발사</strong>: Anthropic, <a href="https://claude.ai/new">Claude</a></li> <li><strong>특징</strong>: 안전하고 윤리적인 AI를 지향하는 대화형 모델입니다. 사용자와의 상호작용에서 윤리적 기준을 중시하며, 복잡한 질문에도 깊이 있는 답변을 제공합니다. Anthropic은 최근 <strong>“character training”</strong>이라는 새로운 기술을 도입하여 Claude에 더욱 인간적인 특성을 부여했습니다.</li> </ul> <h3 id="perplexity">Perplexity</h3> <ul> <li><strong>개발사</strong>: Perplexity AI, <a href="https://www.perplexity.ai/">Perplexity</a></li> <li><strong>특징</strong>: 자연어 처리 기술을 활용하여 문맥에 맞는 답변을 제공하는 대화형 AI입니다. 사용자 질문에 대한 정확한 답변과 <strong>실시간 정보 검색 기능</strong>을 탑재하고 있습니다. GPT-4, Claude 3, Mistral Large 등 다양한 LLM을 활용하여 정보를 처리합니다.</li> </ul> <h3 id="grok">Grok</h3> <ul> <li><strong>개발사</strong>: xAI, <a href="https://x.ai/">Grok</a></li> <li><strong>특징</strong>: 일론 머스크가 설립한 xAI에서 개발한 대화형 AI 모델입니다. <strong>실시간 정보 접근과 유머 감각</strong>을 특징으로 하며, X(구 트위터) 플랫폼의 데이터를 활용하여 훈련되었습니다. 복잡한 문제 해결과 깊이 있는 대화를 지향합니다.</li> </ul> <h3 id="gemini">Gemini</h3> <ul> <li><strong>개발사</strong>: Googlem, <a href="https://gemini.google.com/?hl=ko">Gemini</a></li> <li><strong>특징</strong>: 멀티모달 AI 모델로, 텍스트, 이미지, 오디오, 비디오 등 다양한 형태의 데이터를 처리할 수 있습니다. <strong>Ultra, Pro, Nano 세 가지 버전</strong>으로 제공되며, 모바일 기기부터 데이터 센터까지 다양한 환경에서 사용 가능합니다. 차세대 AI 모델로서 높은 관심을 받고 있습니다.</li> </ul> <h2 id="코드-생성-및-개발-보조-ai">코드 생성 및 개발 보조 AI</h2> <h3 id="github-copilot">Github Copilot</h3> <ul> <li><strong>개발사</strong>: GitHub 및 OpenAI, <a href="https://github.com/features/copilot">GitHub Copilot</a></li> <li><strong>특징</strong>: 프로그래밍 시 자동으로 코드 조각을 추천해주는 AI 도구입니다. 여러 프로그래밍 언어를 지원하며, 개발자의 생산성을 높이고 코드 작성 시간을 단축시켜줍니다. 최근에는 <strong>보안 취약점 감지 기능</strong>도 추가되었습니다.</li> </ul> <h3 id="cursor-ai">Cursor AI</h3> <ul> <li><strong>개발사</strong>: Cursor AI, <a href="https://www.cursor.com/">Cursor AI</a></li> <li><strong>특징</strong>: 코드 편집기 내에서 AI 기반의 코드 완성 및 오류 수정 기능을 제공하는 도구입니다. 개발 과정에서 발생하는 버그를 자동으로 감지하고 수정 제안을 제공합니다. <strong>GPT-4를 기반</strong>으로 하여 높은 성능을 자랑합니다.</li> </ul> <h3 id="phind">Phind</h3> <ul> <li><strong>개발사</strong>: Phind, <a href="https://www.phind.com/search?home=true">Phind</a></li> <li><strong>특징</strong>: 개발자를 위한 AI 검색 엔진으로, 프로그래밍 관련 질문에 대한 정확한 답변과 코드 예제를 제공합니다. <strong>Stack Overflow나 GitHub의 정보를 기반</strong>으로 빠른 검색 결과를 제공하며, 최신 개발 트렌드와 라이브러리 정보도 실시간으로 업데이트합니다.</li> </ul> <h3 id="replit-ai">Replit AI</h3> <ul> <li><strong>개발사</strong>: Replit, <a href="https://replit.com/ai">Replit AI</a></li> <li><strong>특징</strong>: Replit 개발 환경에 통합된 AI 기반 코딩 보조 도구입니다. 주요 특징은 다음과 같습니다: <ul> <li><strong>실시간 코드 완성 및 제안 제공</strong></li> <li><strong>다양한 프로그래밍 언어 지원</strong></li> <li><strong>코드 디버깅 및 오류 수정 지원</strong></li> <li><strong>자연어 프롬프트를 통한 코드 생성</strong></li> <li><strong>협업 기능을 통한 팀 프로젝트 지원</strong> Replit AI는 초보자부터 경험 많은 개발자까지 모든 수준의 사용자에게 도움을 줄 수 있는 강력한 도구입니다.</li> </ul> </li> </ul> <h2 id="크리에이티브-미디어-ai-모델">크리에이티브 미디어 AI 모델</h2> <h3 id="midjourney">Midjourney</h3> <ul> <li><strong>개발사</strong>: Midjourney, Inc., <a href="https://www.midjourney.com/home">Midjourney</a></li> <li><strong>특징</strong>: 텍스트 설명을 기반으로 이미지를 생성하는 AI 모델입니다. 사용자는 원하는 이미지의 특징을 텍스트로 입력하면 그에 맞는 이미지를 생성해줍니다. 최근 <strong>버전 5</strong>는 더욱 향상된 이미지 품질과 텍스트 렌더링 능력을 보여주며, 디자이너와 아티스트들에게 인기가 높습니다.</li> </ul> <h3 id="runway">Runway</h3> <ul> <li><strong>개발사</strong>: Runway, <a href="https://runwayml.com/">Runway</a></li> <li><strong>특징</strong>: 크리에이터를 위한 AI 도구를 제공하는 플랫폼으로, 텍스트를 기반으로 비디오를 생성하는 <strong>Gen-2</strong> 모델이 유명합니다. 최근 업데이트된 Gen-2 모델은 더 높은 해상도와 부드러운 모션, 향상된 일관성을 제공합니다. 이미지와 비디오 편집에 특화된 다양한 AI 기능을 제공하여 콘텐츠 제작을 혁신하고 있습니다.</li> </ul> <h3 id="이디오그램-20">이디오그램 2.0</h3> <ul> <li><strong>개발사</strong>: Ideogram AI, <a href="https://ideogram.ai/login">이디오그램 2.0</a></li> <li><strong>특징</strong>: 텍스트를 기반으로 이미지를 생성하는 AI 모델로, 특히 <strong>이미지 내 텍스트 생성에 강점</strong>이 있습니다. 로고, 포스터, 광고 디자인 등 다양한 분야에서 활용되며, <strong>무료로 사용할 수 있는</strong> 점이 특징입니다.</li> </ul> <h3 id="napkin-ai">Napkin AI</h3> <ul> <li><strong>개발사</strong>: Napkin AI, <a href="https://www.napkin.ai/">Napkin AI</a></li> <li><strong>특징</strong>: 텍스트를 인포그래픽으로 변환하는 AI 기반 도구입니다. 주요 특징은 다음과 같습니다: <ul> <li><strong>텍스트 입력을 기반으로 다양한 스타일의 인포그래픽 생성</strong></li> <li><strong>사용자 친화적인 인터페이스로 쉽고 빠른 시각화 제작</strong></li> <li><strong>프레젠테이션, 보고서, 소셜 미디어 콘텐츠 등에 활용 가능</strong></li> <li><strong>다양한 레이아웃 옵션 제공</strong> (선형, 원형, 단계별 등)</li> <li><strong>PNG, PDF 등 다양한 형식으로 내보내기 가능</strong> Napkin AI는 복잡한 정보를 시각적으로 명확하게 전달하고자 하는 사용자들에게 유용한 도구입니다.</li> </ul> </li> </ul> <h3 id="pika">Pika</h3> <ul> <li><strong>개발사</strong>: Pika Labs, <a href="https://pika.art/home">Pika</a></li> <li><strong>특징</strong>: 텍스트-투-비디오 AI 모델로, 사용자의 아이디어를 바탕으로 고품질 비디오를 생성합니다. 최대 <strong>16초 길이의 비디오</strong>를 생성할 수 있으며, 이미지나 기존 비디오를 입력으로 사용할 수도 있습니다.</li> </ul> <h3 id="kling">Kling</h3> <ul> <li><strong>개발사</strong>: Kuaishou Technology, <a href="https://klingai.com/">Kling</a></li> <li><strong>특징</strong>: 중국 기업 Kuaishou Technology에서 개발한 텍스트-투-비디오 AI 모델입니다. 최대 <strong>2분 길이의 1080p 해상도, 30fps 비디오</strong>를 생성할 수 있으며, 복잡한 모션과 물리적 시뮬레이션 능력이 특징입니다.</li> </ul> <h2 id="멀티모달-및-특수-목적-ai-모델">멀티모달 및 특수 목적 AI 모델</h2> <h3 id="meta-movie-gen">Meta Movie Gen</h3> <ul> <li><strong>개발사</strong>: Meta, <a href="https://ai.meta.com/research/movie-gen/">Meta Movie Gen</a></li> <li><strong>특징</strong>: 영화나 비디오 콘텐츠 생성에 특화된 AI 모델로, <strong>16초 길이의 1080p 해상도 비디오</strong>를 생성할 수 있습니다. 텍스트 프롬프트를 기반으로 비디오를 생성하고, 기존 비디오를 편집하는 기능도 제공합니다. 콘텐츠 제작 분야에서의 혁신을 기대하게 합니다.</li> </ul> <h3 id="imagen-3">Imagen 3</h3> <ul> <li><strong>개발사</strong>: Google, <a href="https://deepmind.google/technologies/imagen-3/">Imagen 3</a></li> <li><strong>특징</strong>: Google’s 최신 텍스트-투-이미지 변환 모델로, <strong>Gemini에 통합되어 제공</strong>됩니다. 이전 버전보다 향상된 포토리얼리즘, 프롬프트 이해도, 그리고 불필요한 요소 제거 능력을 보여줍니다.</li> </ul> <h2 id="기타-ai-모델">기타 AI 모델</h2> <h3 id="mistral-ai">Mistral AI</h3> <ul> <li><strong>개발사</strong>: Mistral AI, <a href="https://mistral.ai/">Mistral AI</a></li> <li><strong>특징</strong>: 오픈 소스 언어 모델로서 높은 성능과 효율성을 자랑합니다. <strong>70억 개의 파라미터</strong>를 가진 언어 모델을 공개하여 개발자들이 자유롭게 활용할 수 있도록 지원하며, 다양한 배포 환경을 지원합니다.</li> </ul> <h3 id="moonlight-ai">Moonlight AI</h3> <ul> <li><strong>개발사</strong>: Moonlight AI, <a href="https://www.themoonlight.io/">Moonlight AI</a></li> <li><strong>특징</strong>: 논문 읽기와 이해를 돕는 AI 기반 도구로, 연구자들이 학술 논문을 더 효율적으로 분석하고 이해할 수 있도록 설계되었습니다. 주요 기능으로는 텍스트 하이라이트 및 설명, 이미지 캡처 및 설명, 하이퍼링크 미리보기, 채팅 기능 등이 있습니다. 특히 수식 설명과 하이라이트 설명 기능이 사용자들에게 큰 호응을 얻고 있습니다. Moonlight는 연구자들의 논문 읽기 속도를 크게 향상시키는 도구로, 크롬 익스텐션 형태로 제공되며 현재 무료로 사용할 수 있습니다.</li> </ul>]]></content><author><name></name></author><category term="LLM"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">LangGraph</title><link href="https://chanp5660.github.io/blog/2024/LangGraph/" rel="alternate" type="text/html" title="LangGraph"/><published>2024-10-07T00:00:00+00:00</published><updated>2024-10-07T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/LangGraph</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/LangGraph/"><![CDATA[<p>연결 문서</p> <p>유투브 링크 : <a href="https://www.youtube.com/watch?v=4JdzuB702wI&amp;list=WL&amp;index=38&amp;t=192s">제 RAG 경험은 이제 LangGraph 경험하기 전과 후로 나뉩니다.</a><br/> [[제 RAG 경험은 이제 LangGraph 경험하기 전과 후로 나뉩니다]]</p> <h1 id="langgraph">LangGraph</h1> <p>안녕하세요! 이번 블로그에서는 <strong>LangGraph</strong>에 대해 자세히 알아보겠습니다. LangGraph는 대형 언어 모델(LLM)을 활용하여 상태를 유지하고, 여러 에이전트를 포함한 복잡한 애플리케이션을 쉽게 만들 수 있도록 도와주는 강력한 라이브러리입니다. 이 글을 통해 LangGraph의 주요 특징, 구조, 작동 방식, 그리고 활용 방법까지 초보자도 이해하기 쉽게 설명해 드리겠습니다.</p> <h2 id="langgraph란-무엇인가요">LangGraph란 무엇인가요?</h2> <p>LangGraph는 LangChain 생태계의 일부로 개발된 도구로, 에이전트 런타임에 필요한 주기적 그래프 워크플로우를 효과적으로 생성할 수 있도록 설계되었습니다. 쉽게 말해, 복잡한 작업을 수행하는 여러 에이전트를 관리하고, 상태를 유지하며, 작업 흐름을 제어할 수 있는 도구입니다.</p> <p><img src="https://i.imgur.com/dcOX3nY.png" alt=""/> <a href="https://aifactory.space/task/4239/discussion/1587">LangGraph PDF 발표자료 참고</a></p> <h2 id="왜-langgraph를-사용해야-할까요">왜 LangGraph를 사용해야 할까요?</h2> <p>현대의 인공지능 애플리케이션은 단순한 질문과 답변을 넘어, 복잡한 상호작용과 상태 관리를 필요로 합니다. 예를 들어, 여러 단계의 대화나 조건에 따라 다른 행동을 수행하는 시스템을 구축하려면 복잡성이 급증합니다. LangGraph는 이러한 복잡성을 효과적으로 관리하고, 개발자가 더 쉽게 애플리케이션을 구축할 수 있도록 도와줍니다.</p> <h2 id="langgraph의-주요-특징">LangGraph의 주요 특징</h2> <h3 id="순환-및-분기">순환 및 분기</h3> <p>LangGraph를 사용하면 애플리케이션에서 <strong>루프</strong>와 <strong>조건문</strong>을 구현할 수 있습니다. 이는 프로그램이 특정 조건에 따라 반복적으로 작업을 수행하거나, 상황에 따라 다른 경로를 선택할 수 있다는 것을 의미합니다.</p> <ul> <li><strong>예시</strong>: 사용자의 입력이 만족스러운 답변을 얻을 때까지 질문을 반복하거나, 사용자의 응답에 따라 다른 프로세스를 진행하는 챗봇을 만들 수 있습니다.</li> </ul> <h3 id="상태-관리">상태 관리</h3> <p>각 단계 후 상태를 자동으로 저장하여 <strong>오류 복구</strong>, <strong>인간 개입 워크플로우</strong>, <strong>시간 여행</strong> 등을 지원합니다. 이는 시스템이 중간에 오류가 발생하더라도 이전 상태로 돌아가 작업을 재개할 수 있음을 의미합니다.</p> <ul> <li><strong>예시</strong>: 장기적인 대화에서 이전 대화 내용을 기억하거나, 작업 진행 상황을 저장하여 나중에 이어서 작업할 수 있습니다.</li> </ul> <h3 id="인간-개입">인간 개입</h3> <p>에이전트가 계획한 다음 작업을 <strong>승인</strong>하거나 <strong>편집</strong>하기 위해 그래프 실행을 중단할 수 있습니다. 이는 기존 방식과 비교하여 다음과 같은 장점을 제공합니다:</p> <ul> <li><strong>더 나은 품질 보장</strong>: 기존에는 AI가 생성한 결과를 그대로 사용하는 경우가 많아 오류 발생 가능성이 있었습니다. 하지만 LangGraph는 인간이 개입하여 결과를 검토하고 수정함으로써 품질을 높일 수 있습니다.</li> <li><strong>협업 강화</strong>: 인간과 AI가 협업하여 더 나은 결과를 도출할 수 있습니다. 기존 시스템에서는 AI의 자동화된 결정에 의존했지만, LangGraph는 인간의 판단을 추가하여 신뢰성을 높입니다.</li> <li><strong>예시</strong>: 에이전트가 작성한 문서를 사람이 검토하고 수정한 후 최종적으로 배포하는 워크플로우를 구축할 수 있습니다. 이는 기존의 자동화된 프로세스보다 더 높은 정확성과 품질을 제공합니다. <h3 id="스트리밍-지원">스트리밍 지원</h3> </li> </ul> <p><strong>스트리밍 지원</strong> 기능은 각 노드에서 생성되는 출력을 실시간으로 확인할 수 있게 해주는 장점이 있습니다. 이는 기존 시스템에서 최종 결과만 확인할 수 있었던 것과 비교하여, 중간 결과를 실시간으로 모니터링하고 필요한 경우 즉각적으로 대응할 수 있도록 해줍니다.</p> <ul> <li><strong>기존 시스템</strong>: 최종 결과만 확인 가능</li> <li><strong>LangGraph</strong>: 중간 결과를 실시간으로 스트리밍하여 확인 가능</li> </ul> <p>이러한 차이는 특히 대용량 데이터 처리나 실시간 응답이 필요한 애플리케이션에서 매우 유용합니다. 예를 들어, 실시간 번역 서비스에서는 문장이 완성되기 전에 부분적으로 번역 결과를 보여줄 수 있어 사용자 경험을 향상시킬 수 있습니다.</p> <h3 id="langchain-통합">LangChain 통합</h3> <p>LangGraph는 <strong>LangChain</strong> 및 <strong>LangSmith</strong>와 원활하게 통합됩니다. 이를 통해 기존의 LangChain 생태계를 활용하여 더욱 강력한 애플리케이션을 구축할 수 있습니다.</p> <ul> <li><strong>예시</strong>: LangChain에서 제공하는 다양한 모델과 도구를 LangGraph와 함께 사용하여 개발 효율을 높일 수 있습니다.</li> </ul> <h2 id="langgraph의-구조-및-작동-방식">LangGraph의 구조 및 작동 방식</h2> <p>LangGraph는 다음과 같은 주요 구성 요소로 이루어져 있습니다:</p> <h3 id="노드-node">노드 (Node)</h3> <ul> <li><strong>역할</strong>: LLM 에이전트를 나타내며, 특정 작업을 수행합니다.</li> <li><strong>특징</strong>: 각 노드는 입력을 받아 처리를 수행한 후, 결과를 출력합니다.</li> </ul> <h3 id="엣지-edge">엣지 (Edge)</h3> <ul> <li><strong>역할</strong>: 에이전트 간의 통신 채널로, 노드 사이의 데이터 흐름을 관리합니다.</li> <li><strong>특징</strong>: 한 노드의 출력이 다른 노드의 입력으로 연결됩니다.</li> </ul> <h3 id="상태-state">상태 (State)</h3> <ul> <li><strong>역할</strong>: 여러 상호작용에 걸쳐 정보를 추적하고 유지합니다.</li> <li><strong>특징</strong>: 시스템의 현재 상황이나 컨텍스트를 저장하여, 다음 작업에 활용합니다.</li> </ul> <h3 id="그래프-graph">그래프 (Graph)</h3> <ul> <li><strong>역할</strong>: 노드와 엣지의 집합으로, 전체 워크플로우를 나타냅니다.</li> <li><strong>특징</strong>: 복잡한 작업 흐름을 시각적으로 표현하고 관리합니다.</li> </ul> <h3 id="작동-방식">작동 방식</h3> <ol> <li><strong>그래프 구성</strong>: 노드와 엣지를 정의하여 그래프를 만듭니다.</li> <li><strong>상태 초기화</strong>: 필요한 초기 상태를 설정합니다.</li> <li><strong>그래프 실행</strong>: 노드 간의 데이터 흐름에 따라 작업을 수행합니다.</li> <li><strong>상태 업데이트</strong>: 각 단계 후에 상태를 업데이트하여 다음 작업에 반영합니다.</li> </ol> <h2 id="활용-및-이점">활용 및 이점</h2> <h3 id="복잡한-에이전트-시스템-구축">복잡한 에이전트 시스템 구축</h3> <table> <tbody> <tr> <td>LangGraph를 사용하면 여러 LLM [[AI 에이전트</td> <td>에이전트]]가 협력하여 작업을 수행해야 하는 복잡한 시스템을 쉽게 구축할 수 있습니다.</td> </tr> </tbody> </table> <ul> <li><strong>예시</strong>: 문서 생성, 검토, 번역, 요약 등 여러 단계를 거치는 프로세스를 관리할 수 있습니다.</li> </ul> <h3 id="상태-유지-필요성">상태 유지 필요성</h3> <p><strong>장기적인 대화</strong>나 <strong>다단계 작업</strong>에서 컨텍스트를 유지해야 하는 경우에 유용합니다.</p> <ul> <li><strong>예시</strong>: 고객 서비스 챗봇이 이전 대화 내용을 기억하고 적절한 대응을 하는 시스템을 만들 수 있습니다.</li> </ul> <h3 id="유연한-워크플로우">유연한 워크플로우</h3> <p>동적으로 변화하는 조건에 따라 다른 작업을 수행해야 할 때, 순환 및 분기 기능을 활용할 수 있습니다.</p> <ul> <li><strong>예시</strong>: 사용자의 선택에 따라 다른 경로로 진행되는 인터랙티브 스토리나 게임을 개발할 수 있습니다.</li> </ul> <h3 id="인간-ai-협업">인간-AI 협업</h3> <p>에이전트의 작업을 검토하고 승인하는 과정이 필요한 경우에 인간 개입 기능을 사용할 수 있습니다.</p> <ul> <li><strong>예시</strong>: AI가 작성한 코드나 문서를 사람이 검토하여 품질을 향상시킬 수 있습니다.</li> </ul> <h2 id="langgraph-시작하기">LangGraph 시작하기</h2> <h3 id="설치-방법">설치 방법</h3> <p>LangGraph를 사용하려면 먼저 라이브러리를 설치해야 합니다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>langgraph
</code></pre></div></div> <h3 id="기본-사용법">기본 사용법</h3> <ol> <li><strong>노드 정의</strong>: 각 에이전트의 역할을 정의합니다.</li> <li><strong>엣지 정의</strong>: 노드 간의 데이터 흐름을 설정합니다.</li> <li><strong>그래프 생성</strong>: 노드와 엣지를 조합하여 그래프를 만듭니다.</li> <li><strong>상태 관리</strong>: 필요한 경우 상태를 초기화하고 업데이트합니다.</li> <li><strong>그래프 실행</strong>: <code class="language-plaintext highlighter-rouge">graph.run()</code>을 호출하여 워크플로우를 실행합니다.</li> </ol> <h3 id="예제-코드">예제 코드</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">langgraph</span> <span class="kn">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">Graph</span>

<span class="c1"># 노드 정의
</span><span class="k">class</span> <span class="nc">InputNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">state</span><span class="p">[</span><span class="sh">'</span><span class="s">input</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="nf">input</span><span class="p">(</span><span class="sh">"</span><span class="s">질문을 입력하세요: </span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span>

<span class="k">class</span> <span class="nc">ProcessNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">state</span><span class="p">[</span><span class="sh">'</span><span class="s">output</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">당신의 질문은 </span><span class="sh">'</span><span class="si">{</span><span class="n">state</span><span class="p">[</span><span class="sh">'</span><span class="s">input</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">'</span><span class="s"> 입니다.</span><span class="sh">"</span>
        <span class="k">return</span> <span class="n">state</span>

<span class="k">class</span> <span class="nc">OutputNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="sh">'</span><span class="s">output</span><span class="sh">'</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">state</span>

<span class="c1"># 노드 인스턴스 생성
</span><span class="n">input_node</span> <span class="o">=</span> <span class="nc">InputNode</span><span class="p">()</span>
<span class="n">process_node</span> <span class="o">=</span> <span class="nc">ProcessNode</span><span class="p">()</span>
<span class="n">output_node</span> <span class="o">=</span> <span class="nc">OutputNode</span><span class="p">()</span>

<span class="c1"># 엣지 설정
</span><span class="n">edge1</span> <span class="o">=</span> <span class="nc">Edge</span><span class="p">(</span><span class="n">input_node</span><span class="p">,</span> <span class="n">process_node</span><span class="p">)</span>
<span class="n">edge2</span> <span class="o">=</span> <span class="nc">Edge</span><span class="p">(</span><span class="n">process_node</span><span class="p">,</span> <span class="n">output_node</span><span class="p">)</span>

<span class="c1"># 그래프 생성
</span><span class="n">graph</span> <span class="o">=</span> <span class="nc">Graph</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">input_node</span><span class="p">,</span> <span class="n">process_node</span><span class="p">,</span> <span class="n">output_node</span><span class="p">],</span>
              <span class="n">edges</span><span class="o">=</span><span class="p">[</span><span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">])</span>

<span class="c1"># 그래프 실행
</span><span class="n">graph</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
</code></pre></div></div> <p>위의 코드는 간단한 입력-처리-출력 워크플로우를 보여줍니다.</p> <h2 id="결론">결론</h2> <p>LangGraph는 LLM 기반의 복잡한 애플리케이션을 구축하고 관리하는 데 매우 유용한 도구입니다. 순환과 분기, 상태 관리, 인간 개입, 스트리밍 지원 등 다양한 기능을 제공하여 개발자들이 더욱 효율적으로 작업할 수 있습니다.</p> <p>특히 초보자도 쉽게 접근할 수 있도록 설계되어 있으므로, LLM을 활용한 애플리케이션 개발에 관심이 있는 분들께 적극 추천드립니다.</p>]]></content><author><name></name></author><category term="LLM/LangGraph"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">al-folio toc 표시</title><link href="https://chanp5660.github.io/blog/2024/al-folio-toc-%ED%91%9C%EC%8B%9C/" rel="alternate" type="text/html" title="al-folio toc 표시"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/al-folio-toc-%ED%91%9C%EC%8B%9C</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/al-folio-toc-%ED%91%9C%EC%8B%9C/"><![CDATA[<p>연결 문서</p> <p><a href="https://alshedivat.github.io/al-folio/blog/2023/sidebar-table-of-contents/">a post with table of contents on a sidebar</a><br/> <a href="https://afeld.github.io/bootstrap-toc/">Table of Contents plugin for Bootstrap</a></p> <h1 id="al-folio-toc-표시">al-folio toc 표시</h1> <p>이 글은 포스트에 사이드바 형식으로 목차(Table of Contents, TOC)를 추가하는 방법을 설명함. 요약하자면 아래와 같음:</p> <ol> <li><strong>목차 추가 방법</strong>: <ul> <li>글의 front matter(프론트 매터)에 아래와 같은 코드를 추가하여 사이드바에 목차를 표시할 수 있음. <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">toc</span><span class="pi">:</span>
  <span class="na">sidebar</span><span class="pi">:</span> <span class="s">left</span>
</code></pre></div> </div> </li> <li>이 코드는 왼쪽에 목차를 나타내는 예시이며, “left”를 “right”로 변경하면 목차를 오른쪽에 표시할 수 있음.</li> <li>목차는 글의 제목과 부제목을 기반으로 자동 생성됨.</li> </ul> </li> <li><strong>목차 커스터마이징</strong>: <ul> <li>더 자세히 커스터마이징 하고 싶다면, <code class="language-plaintext highlighter-rouge">bootstrap-toc</code> 문서를 참고할 것을 권장함. <ul> <li>Bootstrap : <strong>Bootstrap</strong>은 웹 페이지를 쉽게 디자인할 수 있도록 도와주는 오픈소스 도구 모음임.</li> </ul> </li> <li>목차에 표시되는 제목 텍스트도 수정 가능함.</li> </ul> </li> </ol> <h2 id="옵시디언-파일의-table-of-contents-와-겹치는-문제-해결">옵시디언 파일의 table-of-contents 와 겹치는 문제 해결</h2> <ul> <li>옵시디언에서는 를 사용하는데 이러면 2개의 toc 가 생기는 문제가 생기고 실제로 html로는 표시가 되지 않는 문제가 발생</li> <li>이를 해결하기 위해서 옵시디언 동기화 파일에서 를 직접 제거해주는 코드를 추가한다. <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 'table-of-contents[\s\S]*?```', '', content_without_front_matter, flags=re.MULTILINE)
</span></code></pre></div> </div> </li> <li>또한 프론트매터에 toc 표시 조건을 추가한다. <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 프론트매터에 'toc: sidebar: left' 추가
</span><span class="n">metadata</span><span class="p">[</span><span class="sh">'</span><span class="s">toc</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">sidebar</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">left</span><span class="sh">'</span><span class="p">}</span>
</code></pre></div> </div> </li> </ul> <h2 id="bootstrap-기반의-웹-페이지에-자동으로-목차table-of-contents-toc를-생성해주는-플러그인-사용-방법과-커스터마이징">Bootstrap 기반의 웹 페이지에 자동으로 목차(Table of Contents, TOC)를 생성해주는 플러그인 사용 방법과 커스터마이징</h2> <p>주요 기능은 <a href="https://chanp5660.github.io/blog/2024/앵커-링크/">앵커 링크</a> 를 사용해서 문서 탐색 속도를 향상 시킴.</p> <ol> <li><strong>플러그인의 기능</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">&lt;h1&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;h2&gt;</code> 등 제목 요소를 기반으로 자동으로 목차를 생성함.</li> <li>Bootstrap v3 문서 사이트의 사이드바처럼 페이지의 목차를 자동으로 업데이트해줌.</li> <li>제목에 ID가 없으면 자동으로 ID가 생성되며, 이 ID는 URL로 앵커 링크를 걸 수 있게 해줌.</li> </ul> </li> <li><strong>설치 및 설정</strong>: <ul> <li>jQuery와 Bootstrap(v4 또는 v5)을 세팅한 후, 아래 코드를 추가하여 플러그인을 활성화함. <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div> </div> </li> <li>목차를 표시할 위치에 <code class="language-plaintext highlighter-rouge">&lt;nav id="toc" data-toggle="toc"&gt;&lt;/nav&gt;</code> 요소를 추가함.</li> <li>Bootstrap의 Scrollspy 플러그인을 사용하여, <code class="language-plaintext highlighter-rouge">&lt;body&gt;</code> 요소에 추가 설정을 해야 함.</li> </ul> </li> <li><strong>레이아웃 설정</strong>: <ul> <li>Bootstrap의 Scrollspy 기능을 이용하여 페이지 내에서 스크롤할 때, 목차가 자동으로 활성화됨.</li> <li>목차를 화면에 고정(sticky)하거나 모바일에서 목차를 상단에 배치할 수 있는 레이아웃 구성을 제공함.</li> </ul> </li> <li><strong>커스터마이징</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">Toc.init()</code>을 통해 jQuery 객체로 특정 제목만 선택하거나 목차의 표시 형식을 수정할 수 있음.</li> <li><code class="language-plaintext highlighter-rouge">&lt;h2&gt;</code> 등의 제목 요소에 <code class="language-plaintext highlighter-rouge">data-toc-text</code> 속성을 추가하여 목차에 표시되는 텍스트를 사용자 정의할 수 있음.</li> <li>특정 제목을 목차에 포함시키지 않으려면, <code class="language-plaintext highlighter-rouge">data-toc-skip</code> 속성을 추가함.</li> </ul> </li> <li><strong>추가 사항</strong>: <ul> <li>작은 화면에서는 목차가 확장되지 않도록 하거나, 두 번째 레벨의 목차도 표시되도록 선택할 수 있음.</li> </ul> </li> </ol> <h2 id="toc-목차-h4-까지-표시하기">Toc 목차 H4 까지 표시하기</h2> <p>al-folio Jekyll 테마에서 <strong>H4</strong>까지의 제목을 목차(TOC) 사이드바에 표시하려면, TOC가 초기화되는 JavaScript 파일을 수정해야 함. 관련 파일은 <code class="language-plaintext highlighter-rouge">common.js</code>임.</p> <p><strong>수정 방법:</strong></p> <ol> <li> <p><strong><code class="language-plaintext highlighter-rouge">common.js</code> 파일 찾기:</strong></p> <p>이 파일은 일반적으로 al-folio Jekyll 테마의 <code class="language-plaintext highlighter-rouge">assets/js/</code> 디렉터리에 있음.</p> </li> <li> <p><strong>TOC 초기화 코드 수정:</strong></p> <p><code class="language-plaintext highlighter-rouge">common.js</code>에서 TOC가 초기화되는 부분을 찾음. 대략 다음과 같이 생김:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bootstrap-toc</span>
<span class="k">if </span><span class="p">(</span><span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#toc-sidebar</span><span class="dl">"</span><span class="p">).</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// remove related publications years from the TOC</span>
  <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">.publications h2</span><span class="dl">"</span><span class="p">).</span><span class="nf">each</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">attr</span><span class="p">(</span><span class="dl">"</span><span class="s2">data-toc-skip</span><span class="dl">"</span><span class="p">,</span> <span class="dl">""</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="kd">var</span> <span class="nx">navSelector</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#toc-sidebar</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">$myNav</span> <span class="o">=</span> <span class="nf">$</span><span class="p">(</span><span class="nx">navSelector</span><span class="p">);</span>
  <span class="nx">Toc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">$myNav</span><span class="p">);</span>
  <span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">body</span><span class="dl">'</span><span class="p">).</span><span class="nf">scrollspy</span><span class="p">({</span>
    <span class="na">target</span><span class="p">:</span> <span class="nx">navSelector</span><span class="p">,</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>TOC 초기화 코드에서 H4 제목을 포함하도록 수정:</strong></p> <p><code class="language-plaintext highlighter-rouge">Toc.init()</code> 함수 호출을 <code class="language-plaintext highlighter-rouge">$scope</code> 옵션으로 수정하여 포함할 제목 레벨을 지정함.</p> <p><strong>이 부분을:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Toc</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">$myNav</span><span class="p">);</span>
</code></pre></div> </div> <p><strong>다음과 같이 변경:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Toc</span><span class="p">.</span><span class="nf">init</span><span class="p">({</span>
  <span class="na">$nav</span><span class="p">:</span> <span class="nx">$myNav</span><span class="p">,</span>
  <span class="na">$scope</span><span class="p">:</span> <span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">h2, h3, h4</span><span class="dl">'</span><span class="p">),</span> <span class="c1">// H2, H3, H4 제목 포함</span>
<span class="p">});</span>
</code></pre></div> </div> <p>이 수정은 TOC 플러그인에 <code class="language-plaintext highlighter-rouge">&lt;h2&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;h3&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;h4&gt;</code> 제목을 포함하도록 지시함.</p> </li> <li> <p><strong>변경 사항 저장 후 사이트 재빌드:</strong></p> <p><code class="language-plaintext highlighter-rouge">common.js</code> 파일을 저장한 후, Jekyll 사이트를 재빌드하여 업데이트된 TOC를 확인함.</p> </li> </ol> <p><strong>설명:</strong></p> <ul> <li><strong>왜 <code class="language-plaintext highlighter-rouge">common.js</code> 파일을 수정하는가?</strong>: 이 파일은 al-folio 테마에서 TOC 플러그인을 초기화하는 코드를 포함하고 있음.</li> <li><strong><code class="language-plaintext highlighter-rouge">$scope</code> 사용 이유:</strong> 기본적으로 TOC 플러그인은 여러 번 나타나는 제목 수준을 기준으로 포함할 제목을 결정함. <code class="language-plaintext highlighter-rouge">$scope</code> 옵션을 사용하면 명시적으로 포함할 제목 레벨을 정의할 수 있음.</li> <li><strong>H4 제목 포함:</strong> <code class="language-plaintext highlighter-rouge">$scope</code> 선택기에 <code class="language-plaintext highlighter-rouge">'h4'</code>를 추가하면 <code class="language-plaintext highlighter-rouge">&lt;h4&gt;</code> 제목도 TOC에 포함됨.</li> </ul> <p><strong>최종 수정된 <code class="language-plaintext highlighter-rouge">common.js</code> 코드:</strong></p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nf">ready</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// add toggle functionality to abstract, award and bibtex buttons</span>
  <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">a.abstract</span><span class="dl">"</span><span class="p">).</span><span class="nf">click</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.abstract.hidden</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.award.hidden.open</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.bibtex.hidden.open</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">a.award</span><span class="dl">"</span><span class="p">).</span><span class="nf">click</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.abstract.hidden.open</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.award.hidden</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.bibtex.hidden.open</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">a.bibtex</span><span class="dl">"</span><span class="p">).</span><span class="nf">click</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.abstract.hidden.open</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.award.hidden.open</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
    <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">parent</span><span class="p">().</span><span class="nf">parent</span><span class="p">().</span><span class="nf">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">.bibtex.hidden</span><span class="dl">"</span><span class="p">).</span><span class="nf">toggleClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">open</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">).</span><span class="nf">removeClass</span><span class="p">(</span><span class="dl">"</span><span class="s2">waves-effect waves-light</span><span class="dl">"</span><span class="p">);</span>

  <span class="c1">// bootstrap-toc</span>
  <span class="k">if </span><span class="p">(</span><span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#toc-sidebar</span><span class="dl">"</span><span class="p">).</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// remove related publications years from the TOC</span>
    <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">.publications h2</span><span class="dl">"</span><span class="p">).</span><span class="nf">each</span><span class="p">(</span><span class="nf">function </span><span class="p">()</span> <span class="p">{</span>
      <span class="nf">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nf">attr</span><span class="p">(</span><span class="dl">"</span><span class="s2">data-toc-skip</span><span class="dl">"</span><span class="p">,</span> <span class="dl">""</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="kd">var</span> <span class="nx">navSelector</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#toc-sidebar</span><span class="dl">"</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">$myNav</span> <span class="o">=</span> <span class="nf">$</span><span class="p">(</span><span class="nx">navSelector</span><span class="p">);</span>
    <span class="nx">Toc</span><span class="p">.</span><span class="nf">init</span><span class="p">({</span>
      <span class="na">$nav</span><span class="p">:</span> <span class="nx">$myNav</span><span class="p">,</span>
      <span class="na">$scope</span><span class="p">:</span> <span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">h2, h3, h4</span><span class="dl">'</span><span class="p">),</span> <span class="c1">// H2, H3, H4 제목 포함</span>
    <span class="p">});</span>
    <span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">body</span><span class="dl">'</span><span class="p">).</span><span class="nf">scrollspy</span><span class="p">({</span>
      <span class="na">target</span><span class="p">:</span> <span class="nx">navSelector</span><span class="p">,</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="c1">// add css to jupyter notebooks</span>
  <span class="c1">// ... 나머지 코드 ...</span>
<span class="p">});</span>
</code></pre></div></div> <p>이 과정을 따르면 목차 사이드바에 <strong>H4</strong>까지의 제목이 표시됨.</p> <hr/> <p><strong>추가 참고사항:</strong></p> <ul> <li>더 깊은 제목 수준(H5, H6 등)을 포함하려면 <code class="language-plaintext highlighter-rouge">$scope</code> 선택기를 다음과 같이 확장 가능:</li> </ul> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Toc</span><span class="p">.</span><span class="nf">init</span><span class="p">({</span>
  <span class="na">$nav</span><span class="p">:</span> <span class="nx">$myNav</span><span class="p">,</span>
  <span class="na">$scope</span><span class="p">:</span> <span class="nf">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">h2, h3, h4, h5, h6</span><span class="dl">'</span><span class="p">),</span>
<span class="p">});</span>
</code></pre></div></div> <p>컨텐츠 구조에 따라 제목 레벨을 조정하면 됨.</p> <ul> <li>Header 에 <code class="language-plaintext highlighter-rouge">## 1. 제목</code> 과 같은 형태는 bootstrap-toc 움직임이 제대로 따라가지 않음, <code class="language-plaintext highlighter-rouge">## 제목 1.2</code> 이런 형태는 움직임이 제대로 따라감</li> </ul> <p>움직임을 따라가는 예시</p> <p><img src="https://i.imgur.com/R1zxXGK.png" alt=""/></p> <p>움직임을 못 따라가는 예시</p> <p><img src="https://i.imgur.com/Z5316pC.png" alt=""/></p> <h3 id="toc-가-한칸-위가-표시되는-문제">toc 가 한칸 위가 표시되는 문제</h3> <p><code class="language-plaintext highlighter-rouge">.</code> 이 있지만 따라가는 형식 ( 한칸 위가 표시되는 것은 원래부터 그랬기도 하고 내용을 이해하는데 크게 문제가 있을 것 같지 않아서 해결하지 않음 ) <img src="https://i.imgur.com/EfvFIMb.png" alt=""/></p>]]></content><author><name></name></author><category term="블로그/Jekyll/al-folio"/><summary type="html"><![CDATA[연결 문서]]></summary></entry><entry><title type="html">앵커 링크</title><link href="https://chanp5660.github.io/blog/2024/%EC%95%B5%EC%BB%A4-%EB%A7%81%ED%81%AC/" rel="alternate" type="text/html" title="앵커 링크"/><published>2024-10-06T00:00:00+00:00</published><updated>2024-10-06T00:00:00+00:00</updated><id>https://chanp5660.github.io/blog/2024/%EC%95%B5%EC%BB%A4-%EB%A7%81%ED%81%AC</id><content type="html" xml:base="https://chanp5660.github.io/blog/2024/%EC%95%B5%EC%BB%A4-%EB%A7%81%ED%81%AC/"><![CDATA[<p>연결 문서</p> <h1 id="앵커-링크">앵커 링크</h1> <p>앵커 링크(Anchor Link)는 웹 페이지 내에서 특정 위치로 이동할 수 있도록 해주는 하이퍼링크의 한 유형임. 사용자가 앵커 링크를 클릭하면 해당 페이지 내의 지정된 위치(일반적으로 특정 제목이나 섹션)로 스크롤됨.</p> <h3 id="주요-개념">주요 개념:</h3> <ol> <li><strong>앵커(Anchor)</strong>: <ul> <li>앵커는 HTML에서 특정 요소에 고유한 <strong>ID</strong>를 지정하여 페이지 내의 특정 지점을 나타냄.</li> <li>예를 들어, <code class="language-plaintext highlighter-rouge">&lt;h2 id="section1"&gt;섹션 1&lt;/h2&gt;</code>처럼 제목에 ID를 추가하면, 이 ID가 앵커가 됨.</li> </ul> </li> <li><strong>링크 생성</strong>: <ul> <li>앵커 링크는 일반적인 링크와 유사하지만, 링크가 웹 페이지 외부로 이동하는 대신 페이지 내의 특정 위치로 이동하게 함.</li> <li>링크를 만들 때, <code class="language-plaintext highlighter-rouge">href</code> 속성에 앵커의 ID를 사용함. 예를 들어, 아래와 같이 ID가 “section1”인 위치로 이동하는 링크를 만들 수 있음. <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"#section1"</span><span class="nt">&gt;</span>섹션 1으로 이동<span class="nt">&lt;/a&gt;</span>
</code></pre></div> </div> </li> <li>클릭하면 해당 페이지 내에서 “section1”이라는 ID가 있는 곳으로 바로 이동함.</li> </ul> </li> <li><strong>URL 프래그먼트(Fragment)</strong>: <ul> <li>앵커 링크를 클릭하면 웹 페이지 URL에 <strong>프래그먼트</strong>가 추가됨. 예를 들어, <code class="language-plaintext highlighter-rouge">#section1</code>이 URL에 추가되며, 이는 사용자가 페이지의 그 부분으로 스크롤된다는 의미임.</li> <li>URL 예시: <code class="language-plaintext highlighter-rouge">https://example.com/page#section1</code>.</li> </ul> </li> </ol> <h3 id="사용-예">사용 예:</h3> <p>앵커 링크는 긴 문서나 여러 섹션으로 나뉜 페이지에서 유용함. 예를 들어, FAQ 페이지나 블로그 포스트의 목차에서 각 섹션으로 쉽게 이동할 수 있게 해줌.</p> <h3 id="예시-코드">예시 코드:</h3> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 앵커가 있는 제목 --&gt;</span>
<span class="nt">&lt;h2</span> <span class="na">id=</span><span class="s">"introduction"</span><span class="nt">&gt;</span>Introduction<span class="nt">&lt;/h2&gt;</span>

<span class="c">&lt;!-- 앵커 링크 --&gt;</span>
<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"#introduction"</span><span class="nt">&gt;</span>Introduction으로 이동<span class="nt">&lt;/a&gt;</span>
</code></pre></div></div> <h3 id="주요-특징">주요 특징:</h3> <ul> <li>페이지 내 빠른 이동을 가능하게 함.</li> <li>URL을 통해 특정 섹션에 직접 접근할 수 있음.</li> <li>사용자가 긴 문서에서 필요한 정보를 빠르게 찾는 데 도움을 줌.</li> </ul>]]></content><author><name></name></author><category term="용어"/><summary type="html"><![CDATA[연결 문서]]></summary></entry></feed>